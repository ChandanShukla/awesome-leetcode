# Table of Contents
- [Table of Contents](#table-of-contents)
  - [1. Longest Increasing Subsequence](#1-longest-increasing-subsequence)
  - [2. Generate Parentheses](#2-generate-parentheses)
  - [3. Sort Array By Parity](#3-sort-array-by-parity)
  - [4. Min Cost To Connect All Points](#4-min-cost-to-connect-all-points)
  - [5. Power(x, n)](#5-powerx-n)
  - [6. Critical Connections In A Network](#6-critical-connections-in-a-network)
  - [7. Longest Increasing Path In A Matrix](#7-longest-increasing-path-in-a-matrix)
  - [8. Valid Arrangement of Pairs](#8-valid-arrangement-of-pairs)
  - [9. Next Greater Element II](#9-next-greater-element-ii)
  - [10. Container With Most Water](#10-container-with-most-water)
  - [11. Implement Trie (Prefix Tree)](#11-implement-trie-prefix-tree)
  - [12. Sort The Matrix Diagonally](#12-sort-the-matrix-diagonally)
  - [13. Minimum Window Substring](#13-minimum-window-substring)
  - [14. Increasing Triplet Subsequence](#14-increasing-triplet-subsequence)
  - [15. Target Sum](#15-target-sum)
  - [16. Check If There Is A Valid Partition For The Array](#16-check-if-there-is-a-valid-partition-for-the-array)
  - [17. Longest Consecutive Sequence](#17-longest-consecutive-sequence)
  - [18. Valid Sudoku](#18-valid-sudoku)
  - [19. My Calendar I](#19-my-calendar-i)
  - [20. Sliding Window Maximum](#20-sliding-window-maximum)
  - [21. Best Time To Buy and Sell Stock](#21-best-time-to-buy-and-sell-stock)
  - [22. Maximum Subarray](#22-maximum-subarray)
  - [23. Cracking The Safe](#23-cracking-the-safe)
  - [24. Find If Path Exists In Graph](#24-find-if-path-exists-in-graph)
  - [25. Next Greater Node In Linked List](#25-next-greater-node-in-linked-list)
  - [26. Repeated Substring Pattern](#26-repeated-substring-pattern)
  - [27. Search Suggestion System](#27-search-suggestion-system)
  - [28. Merge K Sorted Lists](#28-merge-k-sorted-lists)
  - [29. Daily Temperatures](#29-daily-temperatures)
  - [30. Merge Intervals](#30-merge-intervals)
  - [31. Word Ladder](#31-word-ladder)
  - [32. 3Sum](#32-3sum)
  - [33. Flatten Binary Tree To Linked List](#33-flatten-binary-tree-to-linked-list)
  - [34. Sum of Subarray Minimums](#34-sum-of-subarray-minimums)
  - [35. Median of Two Sorted Arrays](#35-median-of-two-sorted-arrays)
  - [36. LRU Cache](#36-lru-cache)
  - [37. Gas Station](#37-gas-station)
  - [38. Max Points On A Line](#38-max-points-on-a-line)
  - [39. Largest Rectangle In Histogram](#39-largest-rectangle-in-histogram)
  - [40. Regular Expression Matching](#40-regular-expression-matching)
  - [41. Minimum Deletions To Make Character Frequencies Unique](#41-minimum-deletions-to-make-character-frequencies-unique)
  - [42. Jump Game II](#42-jump-game-ii)
  - [43. Count Good Nodes In Binary Tree](#43-count-good-nodes-in-binary-tree)
  - [44. Unique Paths](#44-unique-paths)
  - [45. Coin Change](#45-coin-change)
  - [46. Is Graph Bipartite ?](#46-is-graph-bipartite-)
  - [47. Frequency of Most Frequent Elements](#47-frequency-of-most-frequent-elements)
  - [48. Group Anagrams](#48-group-anagrams)
  - [49. Satisfiability of Equality Equations](#49-satisfiability-of-equality-equations)
  - [50. Range Sum BST](#50-range-sum-bst)
  - [51. Number of Islands](#51-number-of-islands)
  - [52. Wildcard Matching](#52-wildcard-matching)
  - [53. Min Stack](#53-min-stack)
  - [54. Permutations](#54-permutations)
  - [55. Combinations](#55-combinations)
  - [56. Diameter of Binary Tree](#56-diameter-of-binary-tree)
  - [57. Peak Index In Mountain Array](#57-peak-index-in-mountain-array)
  - [58. Maximum Depth of Binary Tree](#58-maximum-depth-of-binary-tree)
  - [59. Find Minimum In Rotated Sorted Array](#59-find-minimum-in-rotated-sorted-array)
  - [60. Binary Tree Zigzag Level Order Traversal](#60-binary-tree-zigzag-level-order-traversal)
  - [61. Longest Substring Without Repeating Characters](#61-longest-substring-without-repeating-characters)
  - [62. Combination Sum](#62-combination-sum)
  - [63. N-Queens](#63-n-queens)
  - [64. Subsets](#64-subsets)
  - [65. Pascal's Triangle](#65-pascals-triangle)
  - [66. House Robber II](#66-house-robber-ii)
  - [67. Partition Equal Subset Sum](#67-partition-equal-subset-sum)
  - [68. Number of Submatrices That Sum To Target](#68-number-of-submatrices-that-sum-to-target)
  - [69. Shortest Path in Binary Matrix](#69-shortest-path-in-binary-matrix)
  - [70.Validate Binary Search Tree](#70validate-binary-search-tree)
  - [71. Reverse Nodes in k-Group](#71-reverse-nodes-in-k-group)
  - [72. Trapping Rain Water](#72-trapping-rain-water)
  - [73. Find Missing Positive](#73-find-missing-positive)
  - [74. Edit Distance](#74-edit-distance)
  - [75. Climbing Stairs](#75-climbing-stairs)
  - [76. Shifting Letters II](#76-shifting-letters-ii)
  - [77. Build A Matrix With Conditions](#77-build-a-matrix-with-conditions)
  - [78. Serialize and Deserialize Binary Tree](#78-serialize-and-deserialize-binary-tree)
  - [79. Pacific Atlantic Water Flow](#79-pacific-atlantic-water-flow)
  - [80. Delete and Earn](#80-delete-and-earn)
  - [81. Permutations II](#81-permutations-ii)
  - [82. Combination Sum II](#82-combination-sum-ii)
  - [83. Non Overlapping Intervals](#83-non-overlapping-intervals)
  - [84. Best Time To Buy and Sell Stocks With Cooldown](#84-best-time-to-buy-and-sell-stocks-with-cooldown)
  - [85. Maximum XOR of Two Numbers In An Array](#85-maximum-xor-of-two-numbers-in-an-array)
  - [86. Implement Queue Using Stacks](#86-implement-queue-using-stacks)
  - [87. Minimum Size Subarray Sum](#87-minimum-size-subarray-sum)
  - [88. Number of Visible People In A Queue](#88-number-of-visible-people-in-a-queue)
  - [89. Describe The Painting](#89-describe-the-painting)
  - [90. Flood Fill](#90-flood-fill)
  - [91. Palindrome Partitioning](#91-palindrome-partitioning)
  - [92. Path With Maximum Gold](#92-path-with-maximum-gold)
  - [93. Counting Bits](#93-counting-bits)
  - [94. Word Break](#94-word-break)
  - [95. Find Median From Data Stream](#95-find-median-from-data-stream)
  - [96. Single Threaded CPU](#96-single-threaded-cpu)
  - [97. Contiguous Array](#97-contiguous-array)
  - [98. Falling Squares](#98-falling-squares)
  - [99. Minimum XOR Sum of Two Arrays](#99-minimum-xor-sum-of-two-arrays)
  - [100. Maximum Profit In Job Scheduling](#100-maximum-profit-in-job-scheduling)
  - [101. Find Minimum Time To Finish All Jobs](#101-find-minimum-time-to-finish-all-jobs)
  - [102. Course Schedule](#102-course-schedule)
  - [103. Minimum Height Trees](#103-minimum-height-trees)
  - [104. Russian Doll Envelopes](#104-russian-doll-envelopes)
  - [105. Maximum AND Sum of Array](#105-maximum-and-sum-of-array)
  - [106. Maximum Number of Robots Within Budget](#106-maximum-number-of-robots-within-budget)
  - [107. Find Longest Awesome Substring](#107-find-longest-awesome-substring)
  - [108. Maximum Rows Covered By Columns](#108-maximum-rows-covered-by-columns)
  - [109. Create Sorted Array Through Instructions](#109-create-sorted-array-through-instructions)
  - [110. Maximum Students Taking Exam](#110-maximum-students-taking-exam)

## 1. Longest Increasing Subsequence

<details>
<summary> Solution - DP </summary>

```cpp
int lengthOfLIS(vector<int>& nums) {
    int N = nums.size();
    
    vector<int> dp;
    
    for(int i = 0; i < N; i++) {
        
        auto it = lower_bound(dp.begin(), dp.end(), nums[i]);
        
        if(it != dp.end()) {
            *it = nums[i];
        } else {
            dp.push_back(nums[i]);
        }
    }
    
    return dp.size();
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 2. Generate Parentheses

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    
    vector<string> ans;
    
    void backtracking(string &temp, int leftCnt, int rightCnt) {
        
        // We found a valid parentheses.
        if(leftCnt == 0 && rightCnt == 0) {
            ans.push_back(temp);
            return;
        }
        
        // Include left parentheses
        
        if(leftCnt) {
            temp += "(";
            backtracking(temp, leftCnt - 1, rightCnt);
            temp.pop_back();
        }
        
        // Include right parentheses
        
        if(rightCnt > leftCnt) {
            temp += ")";
            backtracking(temp, leftCnt, rightCnt - 1);
            temp.pop_back();
        }
        
    }
    
    vector<string> generateParenthesis(int n) {
        string temp = "";
        backtracking(temp, n, n);
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 3. Sort Array By Parity

<details>
<summary> View Code </summary>

```cpp
vector<int> sortArrayByParity(vector<int>& A) {
    sort(A.begin(), A.end(), [](int a, int b) {
        return a % 2 < b % 2;
    });
    
    return A;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 4. Min Cost To Connect All Points

<details>
<summary> View Code </summary>

```cpp
class UnionFind {
    private:
        vector<int> id, rank;
        int cnt;
    public:
        UnionFind(int cnt) : cnt(cnt) {
            id = vector<int>(cnt);
            rank = vector<int>(cnt, 0);
            for (int i = 0; i < cnt; ++i) id[i] = i;
        }
        int find(int p) {
            if (id[p] == p) return p;
            return id[p] = find(id[p]);
        }
        int getCount() { 
            return cnt; 
        }
        bool connected(int p, int q) { 
            return find(p) == find(q); 
        }
        void connect(int p, int q) {
            int i = find(p), j = find(q);
            if (i == j) return;
            if (rank[i] < rank[j]) {
                id[i] = j;  
            } else {
                id[j] = i;
                if (rank[i] == rank[j]) rank[j]++;
            }
            --cnt;
        }
};

class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        
        int N = points.size();
        
        vector<array<int, 3>> E;
        
        for(int i = 0; i < N; i++) {
            for(int j = i + 1; j < N; j++) {
                E.push_back({abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j});
            }
        }
        
        UnionFind uf(N);
        
        int ans = 0;
        
        // How to convert vector into heap.
        make_heap(E.begin(), E.end(), greater<array<int, 3>>());
        
        while(uf.getCount() > 1) {
            pop_heap(E.begin(), E.end(), greater<array<int, 3>>());
            auto [w, u, v] = E.back();
            
            E.pop_back();
            
            if(uf.connected(u, v)) continue;
            
            uf.connect(u, v);
            ans += w;
        }
        
        return ans;
        
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 5. Power(x, n)

<details>
<summary> View Code </summary>

```cpp
double recursion(double x, long n) {
        
    if(n < 0) {
        return 1 / recursion(x, -n);
    }
    
    if(n == 0) {
        return 1;
    }
    
    if(n == 1) {
        return x;
    }
    
    if(n == 2) {
        return x * x;
    }
    
    return recursion( recursion (x, n / 2), 2) * (n % 2 ? x : 1);
}

double myPow(double x, int n) {
    return recursion(x, (long)n);
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 6. Critical Connections In A Network

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
        vector<int> ranks(n, INT_MIN);
        
        vector<vector<int>> G(n), ans;
        
        for(auto &e : connections) {
            int u = e[0], v = e[1];
            G[u].push_back(v);
            G[v].push_back(u);
        }
        
        function<int(int, int)> dfs = [&](int u, int rank) {
            if(ranks[u] >= 0) return ranks[u];
            
            ranks[u] = rank;
            int minRank = rank;
            
            for(int v : G[u]) {
                
                if(ranks[v] >= rank - 1) continue; 
                
                int neighbourMinRank = dfs(v, rank + 1);
                minRank = min(minRank, neighbourMinRank);
                
                if (neighbourMinRank > rank) {
                    ans.push_back({u, v});
                }
            }
            
            return minRank;
        };
        
        
        dfs(0, 0);
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 7. Longest Increasing Path In A Matrix

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int M, N;
    vector<vector<int>> cnt;
    
    int dirs[4][2] = { {1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    
    int dfs(vector<vector<int>> &A, int i, int j) {
        
        if(cnt[i][j] != -1e9) {
            return cnt[i][j];
        }
        
        cnt[i][j] = 1;
        
        for(auto &dir : dirs) {
            int a = i + dir[0];
            int b = j + dir[1];
            
            if(a < 0 || b < 0 || a >= M || b >= N || A[a][b] <= A[i][j]) continue;
            
            cnt[i][j] = max(cnt[i][j] , 1 + dfs(A, a, b));
        }
        
        return cnt[i][j];
    }
    
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        M = matrix.size();
        N = matrix[0].size();
        
        cnt.assign(M, vector<int>(N, -1e9));
        
        int ans = 0;
        
        for(int i = 0; i < M; i++) {
            for(int j = 0; j < N; j++) {
                ans = max(ans, dfs(matrix, i, j));
            }
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 8. Valid Arrangement of Pairs

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {
        unordered_map<int, vector<int>> G;
        unordered_map<int, int> indegrees, outdegrees;
        
        for(auto &e : pairs) {
            int u = e[0], v = e[1];
            G[u].push_back(v);
            indegrees[v]++;
            outdegrees[u]++;
        }
        
        // Select the starting node.
        int start = -1;
        
        for(auto &[u, ad] : G ) {
            if(outdegrees[u] - indegrees[u] == 1) {
                start = u;
                break;
            }
        }
        
        if(start == -1) {
            start = pairs[0][0];
        }
        
        vector<vector<int>> ans;
        
        function<void(int)> euler = [&](int u) {
            
            auto &ad = G[u];
            
            while(ad.size()) {
                int v = ad.back();
                ad.pop_back();
                
                euler(v);
                ans.push_back({u, v});
            }
        };
        
        euler(start);
        reverse(ans.begin(), ans.end());
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 9. Next Greater Element II

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        int N = nums.size();
        
        // Stores index.
        stack<int> S;
        
        // Stores element
        vector<int> ans(N, -1);
        
        for(int i = 0; i < 2 * N; i++) {
            
            int n = nums[i % N];
            
            while(S.size() && nums[S.top()] < n) {
                ans[S.top()] = n;
                S.pop();
            }
            
            S.push(i % N);
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 10. Container With Most Water

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        
        int N = height.size();
        int L = 0, R = N - 1;
        
        int ans = 0;
        
        while(L < R) {
            int area = min(height[L], height[R]) * (R - L);
            
            ans = max(ans, area);
            
            if(height[L] < height[R]) {
                L++;
            } else {
                R--;
            }
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 11. Implement Trie (Prefix Tree)

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
struct TrieNode {
    TrieNode *next[26] = {};
    bool word = false;
};

class Trie {
    
    TrieNode root;
    
    TrieNode *find(string s) {
        
        auto node = &root;
        
        for(char c : s) {
            if(!node->next[c - 'a']) return NULL;
            
            node = node->next[c - 'a'];
        }
        
        return node;
    }
    
public:
    
    void insert(string word) {
        
        auto node = &root;
        
        for(char c : word) {
            if(!node->next[c - 'a']) node->next[c - 'a'] = new TrieNode();
            
            node = node->next[c - 'a'];
        }
        
        node->word = true;
    }
    
    bool search(string word) {
        auto wordFind = find(word);
        return wordFind && (wordFind->word == true);
    }
    
    bool startsWith(string prefix) {
        return find(prefix);
    }
};
```

## 12. Sort The Matrix Diagonally

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {
        int M = mat.size();
        int N = mat[0].size();
        
        for (int i = 0; i < M; ++i) {
            vector<int> v;
            for (int x = i, y = 0; x < M && y < N; ++x, ++y) {
                v.push_back(mat[x][y]);
            }
            sort(v.begin(), v.end());
            int index = 0;
            for (int x = i, y = 0; x < M && y < N; ++x, ++y) {
                mat[x][y] = v[index++];
            }
        }
        
         for (int j = 1; j < N; ++j) {
             vector<int> v;
             for(int x = 0, y = j; x < M && y < N; ++x, ++y) {
                 v.push_back(mat[x][y]);
             }
             sort(v.begin(), v.end());
             int index = 0;
             for (int x = 0, y = j; x < M && y < N; ++x, ++y) {
                 mat[x][y] = v[index++];
             }
         }
        
        return mat;
    }
};
```

## 13. Minimum Window Substring

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        
        unordered_map<char, int> target, cnt;
        int N = s.length();
        
        // Store the frequency of target string
        for(char c : t) {
            target[c]++;
        }
        
        int matched = 0;
        int start = 0, len = INT_MAX;
        int i = 0;
        
        // Traverse the s string, j - right boundary, left boundary - 0
        for(int j = 0; j < N; j++) {
            
            if(++cnt[s[j]] <= target[s[j]]) matched++;
            
            // Target string comes inside this window substring.
            while(matched == t.size()) {
                
                // Update the answer start and its length
                if(len > j - i + 1) {
                    len = j - i + 1;
                    start = i;
                }
                
                // Decrease the length of window.
                if(--cnt[s[i]] < target[s[i]]) matched--;
                i++;
            }
            
        }
        
        if(len == INT_MAX) {
            return "";
        } else {
            return s.substr(start, len);
        }
    }
};
```

## 14. Increasing Triplet Subsequence

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        
        int N = nums.size();
        
        vector<int> dp;
        
        for(int i = 0; i < N; i++) {
            
            auto it = lower_bound(dp.begin(), dp.end(), nums[i]);
            
            if(it != dp.end()) {
                *it = nums[i];
            } else {
                dp.push_back(nums[i]);
            }
        }
        
        return (dp.size() >= 3);
        
    }
};
```

## 15. Target Sum

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    
    int recur(vector<int>& nums, int sum, int target, int i) {
        int n = nums.size();
        
        if(n == i) {
            // Check the sum if it is equal to target
            if(sum == target) return 1;
            
            return 0;
        }
        
        int res = 0;
        
        // Include
        res += recur(nums, sum + nums[i], target, i + 1);
        
        // Not Include
        res += recur(nums, sum - nums[i], target, i + 1);
        
        return res;
        
    }
    
    int findTargetSumWays(vector<int>& nums, int target) {
        // (vector, sum, target, index);
        return recur(nums, 0, target, 0);
    }
};

class Solution {
public:
    
    int recursion(vector<int>& nums, int i, int target, int n, vector<vector<int>> &dp) {
        if(i == n) {
            if(target == 0) return 1;
            return 0;
        }
        
        if(dp[i][target + 1000] != -1) return dp[i][target + 1000];
        
        int include = recursion(nums, i + 1, target + nums[i], n, dp);
        int notInclude = recursion(nums, i + 1, target - nums[i], n, dp);
        
        dp[i][target + 1000] = include + notInclude;
        return dp[i][target + 1000];
    }
    
    int findTargetSumWays(vector<int>& nums, int target) {
        
        vector<vector<int>> dp(nums.size() + 1, vector<int>(3000, -1));
        
        return recursion(nums, 0, target, nums.size(), dp);
    }
};
```

## 16. Check If There Is A Valid Partition For The Array

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    bool validPartition(vector<int>& nums) {
        int N = nums.size();
        bool dp[N + 1];
        
        for(int i = 0; i <= N; i++) dp[i] = false;
        
        dp[0] = true;
        
        for(int i = 0; i < N; i++) {
            // for two elements
            if(i >= 1) {
                if(dp[i - 1] && nums[i] == nums[i - 1]) {
                    dp[i + 1] = true;
                }
            }
            
            // for three elements
            if(i >= 2) {
                if(dp[i - 2] && nums[i] == nums[i - 1] && nums[i - 1] == nums[i - 2]) {
                    dp[i + 1] = true;
                }
            }
            
            // for three consecutive elements
            if(i >= 2) {
                if(dp[i - 2] && nums[i] == nums[i - 1] + 1 && nums[i - 1] == nums[i - 2] + 1) {
                    dp[i + 1] = true;
                }
            }
        }
        
        return dp[N];
    }
};
```

## 17. Longest Consecutive Sequence

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
// Union Find that also return the vector of size of components.
class UnionFind {
    vector<int> id, size;
public:
    UnionFind(int n) : id(n), size(n, 1) {
        for (int i = 0; i < n; ++i) id[i] = i;
    }
    void connect(int a, int b) {
        int x = find(a), y = find(b);
        if (x == y) return;
        id[x] = y;
        size[y] += size[x];
    }
    int find(int a) {
        return id[a] == a ? a : (id[a] = find(id[a]));
    }
    vector<int> &getSizes() {
        return size;
    }
};

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        
        int N = nums.size();
        
        if(N == 0) {
            return 0;
        }
        
        UnionFind uf(N);
        
        unordered_map<int, int> M;
        
        // We have to store indexes in UnionFind instead of integer values.
        
        for(int i = 0; i < N; i++) {
            int n = nums[i];
            
            if(M.count(n)) continue;
            
            M[n] = i;
            
            if(M.count(n - 1)) uf.connect(M[n], M[n - 1]);
            if(M.count(n + 1)) uf.connect(M[n], M[n + 1]);
        }
        
        // ans -> maximum component size
        vector<int> ans = uf.getSizes();
        return *max_element(ans.begin(), ans.end());
    }
};
```

## 18. Valid Sudoku

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int row[9][9] = {}, col[9][9] = {}, box[9][9] = {};
        
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                int n = board[i][j] - '1';
                
                if(board[i][j] == '.') continue;
                
                if(row[i][n] || col[j][n] || box[(i / 3) * 3 + (j / 3)][n]) return false;
                
                
                row[i][n] = col[j][n] = box[i / 3 * 3 + j / 3][n] = 1;
            }
        }
        
        return true;
    }
};
```

## 19. My Calendar I

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class MyCalendar {
public:
    MyCalendar() {
        
    }

    map<int, int> M;
    
    bool book(int start, int end) {
        
        if(M.empty()) {
            M[start] = end;
            return true;
        }
        
        // Conditions 
        
        auto it = M.upper_bound(start);
        
        // Check the later intersection
        if(it != M.end() && it->first < end) return false;
        
        // Check the starting intersection
        if(it != M.begin() && prev(it)->second > start) return false;
        
        
        // After checking conditions
        M[start] = end;
        return true;
    }
};
```

## 20. Sliding Window Maximum

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int N = nums.size();
        deque<int> d; // Deque will store the index
        
        vector<int> ans;
        
        for(int i = 0; i < N; i++) {
            
            int n = nums[i];
            
            // When the element goes out of window, remove from the deque.
            if(d.size() && d.front() == i - k) d.pop_front();
            
            // We have to store monotonically decreasing sequence.
            while(d.size() && nums[d.back()]  <= n) {
                d.pop_back();
            }
            
            d.push_back(i);
            
            if(i >= k - 1) {
                // Push maximum element in answer.
                ans.push_back(nums[d.front()]);
            }
            
        }
        
        return ans;
    }
};
```

## 21. Best Time To Buy and Sell Stock

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int N = prices.size();
        
        int minStock = prices[0];
        int profit = 0;
        
        for(int i = 0; i < N; i++) {
            minStock = min(minStock, prices[i]);
            
            profit = max(profit, prices[i] - minStock);
        }
        
        return profit;
    }
};
```

## 22. Maximum Subarray

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int maxSubArray(vector<int>& nums) {
    int global = nums[0];
    int local = 0;
    
    int N = nums.size();
    
    for(int i = 0; i < N; i++) {
        local = max(local + nums[i], nums[i]);
        global = max(global, local);
    }
    
    return global;
}
```

## 23. Cracking The Safe

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    
    
    string crackSafe(int n, int k) {
        
        if(n == 1 && k == 1) return "0";
        
        // Store the edges of graph.
        unordered_set<string> M; 
        
        string start = string(n - 1, '0');
        string ans = "";
        
        function<void(string)> euler = [&](string u) {      
            for(char c = '0'; c < k + '0'; c++) {
                // How to use the last sequence optimally
                string v = u + c;

                // We don't have to visit the same edge again
                if(M.count(v)) continue;
                M.insert(v);
                
                euler(v.substr(1));

                ans.push_back(c);
            }
        };
        
        euler(start);
        
        return ans + start;
    }
};
```

## 24. Find If Path Exists In Graph

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        
        // Creation of Graph
        unordered_map<int, vector<int>> G;
        
        for(auto &e : edges) {
            int u = e[0], v = e[1];
            G[u].push_back(v);
            G[v].push_back(u);
        }
        
        // BFS
        
        queue<int> q;
        vector<int> seen(n, 0); // 0 ->unseen
        
        q.push(source);
        seen[source] = 1;
        
        while(q.size()) {
            int v = q.front();
            q.pop();
            // Traverse every edge of v in breadth first search
            
            for(int u : G[v]) {
                if(seen[u]) continue;
                seen[u] = 1;
                q.push(u);
            }
        }
        
        if(seen[destination] == 1) {
            return true;
        } else {
            return false;
        }
    }
};
```

## 25. Next Greater Node In Linked List

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = new ListNode();
        
        while(head) {
            auto node = head;
            head = head->next;
            node->next = prev->next;
            prev->next = node;
        }

        return prev->next;
    }
    
    vector<int> nextLargerNodes(ListNode* head) {
        head = reverseList(head);
        
        stack<int> S;
        vector<int> ans;
        
        
        while(head) {
            
            int n = head->val;
            
            while(S.size() && S.top() <= n) {
                S.pop();
            }
            
            if(S.size() == 0) {
                ans.push_back(0);
            } else {
                ans.push_back(S.top());
            }
            
            S.push(n);
            
            head = head->next;
        }
        
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

## 26. Repeated Substring Pattern

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        int N = s.length();
        
        for(int len = 1; len <= N / 2; len++) {
            if(N % len) continue;
            
            int i = len;
            for(; i < N; i++) {
                if( s[i] != s[i % len]) break;
            }
            
            if(i == N) return true;
        }
        
        return false;
    }
};
```

## 27. Search Suggestion System

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
struct TrieNode {
    TrieNode *next[26] = {};
    int index = -1;
};

void add(TrieNode *node, string &s, int i) {
    
    for(char c: s) {
        if(!node->next[c - 'a']) node->next[c - 'a'] = new TrieNode();
        node = node->next[c - 'a'];
    }
    node->index = i;
}

void collect(TrieNode *node, vector<string> &ans, vector<string> &products) {
    if(ans.size() == 3) return;
    
    if(!node) return;
    
    if(node->index > -1) ans.push_back(products[node->index]);
    
    for(int i = 0; i < 26; i++) {
        if(node->next[i]) collect(node->next[i], ans, products);
    }
}

class Solution {
public:
    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) {
        TrieNode root, *node = &root;
        
        for(int i = 0; i < products.size(); i++) {
            add(&root, products[i], i);
        }
        
        vector<vector<string>> ans(searchWord.size());
        
        for(int i = 0; i < searchWord.length(); i++) {
            node = node->next[searchWord[i] - 'a'];
            
            if(!node) break;
            
            collect(node, ans[i], products);
        }
        
        return ans;
    }
};
```

## 28. Merge K Sorted Lists

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode dummy, *tail = &dummy;
        auto cmp = [](auto a, auto b) { return a->val > b->val; };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> q(cmp);
        for (auto list : lists) {
            if (list) q.push(list); // avoid pushing NULL list.
        }
        while (q.size()) {
            auto node = q.top();
            q.pop();
            if (node->next) q.push(node->next);
            tail->next = node;
            tail = node;
        }
        return dummy.next;
    }
};
```

## 29. Daily Temperatures

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& A) {
        stack<int> s;
        vector<int> ans(A.size());
        for (int i = A.size() - 1; i >= 0; --i) {
            while (s.size() && A[s.top()] <= A[i]) s.pop();
            ans[i] = s.size() ? s.top() - i : 0;
            s.push(i);
        }
        return ans;
    }
};
```

## 30. Merge Intervals

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        
        sort(intervals.begin(), intervals.end());
        vector<vector<int>> ans;
        
        for(auto &a : intervals) {
            if(!ans.size() || a[0] > ans.back()[1]) {
                ans.push_back(a);
            } else if(ans.back()[1] < a[1]) {
                ans.back()[1] = a[1];
            }
        }
        
        return ans;
    }
};
```

## 31. Word Ladder

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
    unordered_set<string> s(begin(wordList), end(wordList));
    if (s.count(endWord) == 0) return 0;
    queue<string> q{{beginWord}};
    s.erase(beginWord);
    int step = 1;
    while (q.size()) {
        int cnt = q.size();
        while (cnt--) {
            auto u = q.front();
            q.pop();
            if (u == endWord) return step;
            for (char &c : u) { // add unvisited neighbors of `u`
                char tmp = c;
                for (char ch = 'a'; ch <= 'z'; ++ch) {
                    if (tmp == ch) continue;
                    c = ch;
                    if (s.count(u) == 0) continue;
                    s.erase(u);
                    q.push(u);
                }
                c = tmp;
            }
        }
        ++step;
    }
    return 0;
}
```

## 32. 3Sum

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
vector<vector<int>> threeSum(vector<int>& A) {
    vector<vector<int>> ans;
    sort(A.begin(), A.end());
    
    int N = A.size();
    int L = 0, R = N - 1;
    
    for(int i = 0; i < N - 2; i++) {
        
        if(i > 0 && A[i] == A[i - 1]) continue;
        
        int L = i + 1, R = N - 1;
        
        while(L < R) {
            int sum = A[i] + A[L] + A[R];
            
            if(sum == 0) {
                ans.push_back({A[i], A[L], A[R]});
            }
            
            if(sum <= 0) {
                L++;

                while(L < R && A[L] == A[L - 1]) L++;
            }
            
            if(sum >= 0) {
                R--;

                while(L < R && A[R] == A[R + 1]) R--;
            }
        }
    }
    
    return ans;
}
```

## 33. Flatten Binary Tree To Linked List

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
void flatten(TreeNode* root) {
    if(!root) return;
    TreeNode *tail = nullptr;
    
    stack<TreeNode*> S;
    
    S.push({root});
    
    while(S.size()) {
        auto node = S.top();
        S.pop();
        
        if(tail) tail->right = node;
        tail = node;
        
        if(node->right) S.push(node->right);
        if(node->left) S.push(node->left);
        
        node->left = node->right = nullptr;
    }
}
```

## 34. Sum of Subarray Minimums

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int sumSubarrayMins(vector<int>& A) {
    stack<int> q;
    q.push(-1);
    long N = A.size(), ans = 0, sum = 0, mod = 1e9+7;
    for (int i = 0; i < N; ++i) {
        sum = (sum + A[i]) % mod;
        while (q.top() != -1 && A[q.top()] >= A[i]) {
            int j = q.top();
            q.pop();
            int c = j - q.top();
            sum = (sum + c * (A[i] - A[j]) % mod) % mod;
        }
        q.push(i);
        ans = (ans + sum) % mod;
    }
    return ans;
}
```

## 35. Median of Two Sorted Arrays

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.size() > nums2.size()) swap(nums1, nums2);
    int M = nums1.size(), N = nums2.size(), L = 0, R = M, K = (M + N + 1) / 2;
    while (true) {
        int i = (L + R) / 2, j = K - i;
        if (i < M && nums2[j - 1] > nums1[i]) L = i + 1;
        else if (i > L && nums1[i - 1] > nums2[j]) R = i - 1;
        else {
            int maxLeft = max(i ? nums1[i - 1] : INT_MIN, j ? nums2[j - 1] : INT_MIN);
            if ((M + N) % 2) return maxLeft;
            int minRight = min(i == M ? INT_MAX : nums1[i], j == N ? INT_MAX : nums2[j]);
            return (maxLeft + minRight) / 2.0;
        }
    }
}
```

## 36. LRU Cache

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class LRUCache {
    int capacity;
    list<pair<int, int>> data;
    unordered_map<int, list<pair<int, int>>::iterator> m;
    void moveToFront(int key) {
        auto node = m[key];
        data.splice(data.begin(), data, node);
        m[key] = data.begin();
    }
public:
    LRUCache(int capacity) : capacity(capacity) {}
    int get(int key) {
        // get node given key, put the node at the beginning of the list, return the value in the node
        if (m.count(key)) {
            moveToFront(key);
            return m[key]->second;
        }
        return -1;
    }
    void put(int key, int value) {
        // if key exists in the map, get node given key, put the node at the beginning of the list and update the value in the node
        // otherwise, put a new node at the beginning of the list with the <key, value> and update the map. If capacity exceeded, remove the last node from the list and map.
        if (m.count(key)) {
            moveToFront(key);
            m[key]->second = value;
        } else {
            data.emplace_front(key, value);
            m[key] = data.begin();
            if (data.size() > capacity) {
                m.erase(data.rbegin()->first);
                data.pop_back();
            }
        }
    }
};
```

## 37. Gas Station

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    int N = gas.size(), len = 0, start = 0;
    for (int i = 0, sum = 0; i < 2 * N && len < N; ++i) {
        sum += gas[i % N] - cost[i % N];
        if (sum < 0) {
            len = sum = 0;
            start = (i + 1) % N;
        } else ++len;
    }
    return len == N ? start : -1;
}
```

## 38. Max Points On A Line

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {
        
        int res = 0;
        for(int i = 0; i<points.size(); i++){
            
            unordered_map<long double,int> noOfPointsInLine;
            
            for(int j = i + 1; j < points.size(); j++){
                
                int x1 = points[i][0], y1 = points[i][1], x2 = points[j][0], y2 = points[j][1];
                
                if(y2 == y1) {     
                    noOfPointsInLine[INT_MIN]++;
                } else if(x1 == x2){ 
                    noOfPointsInLine[INT_MAX]++;
                } else {               
                    long double slope = (long double)(y2 - y1) /(long double)(x2 - x1);
                    noOfPointsInLine[slope]++;
                }
                
            }
            
            for(auto i : noOfPointsInLine){
                res = max(i.second, res);
            }
        }
        return res + 1;
    }
};
```

## 39. Largest Rectangle In Histogram

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& A) {
        int N = A.size();
        
        int ans = 0;
        
        stack<int> S;
        vector<int> next(N, N), prev(N, -1);
        
        for(int i = 0; i < N; i++) {
            while(S.size() && A[i] < A[S.top()]) {
                next[S.top()] = i;
                S.pop();
            }
            S.push(i);
        }
        
        for(int i = N - 1; i >= 0; i--) {
            while(S.size() && A[i] < A[S.top()]) {
                prev[S.top()] = i;
                S.pop();
            }
            S.push(i);
        }
        
        for(int i = 0; i < N; i++) {
            ans = max(ans, A[i] * (next[i] - prev[i] - 1));
        }
        
        return ans;
    }
};
```

## 40. Regular Expression Matching

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
private:
    inline bool matchChar(string &s, int i, string &p, int j) {
        return p[j] == '.' ? i < s.size() : s[i] == p[j];
    }
    bool isMatch(string s, int i, string p, int j) {
        if (j == p.size()) return i == s.size();
        if (j + 1 < p.size() && p[j + 1] == '*') {
            bool ans = false;
            while (!(ans = isMatch(s, i, p, j + 2))
            && matchChar(s, i, p, j)) ++i;
            return ans;
        } else {
            return matchChar(s, i, p, j) && isMatch(s, i + 1, p, j + 1);
        }
    }
public:
    bool isMatch(string s, string p) {
        return isMatch(s, 0, p, 0);
    }
};
```

## 41. Minimum Deletions To Make Character Frequencies Unique

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int minDeletions(string s) {
        int cnt[26] = {0};
        set<int> S;
        int ans = 0;
        for (char c : s) {
          cnt[c - 'a']++;  
        } 
        
        for(int i = 0; i < 26; i++) {
            while(cnt[i]-- && !S.insert(cnt[i]).second) {
                ans++;
            }
        }
        return ans;
    }
};
```

## 42. Jump Game II

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int N = nums.size();
        vector<int> dp(N, 1e9);
        
        dp[0] = 0;
        
        for(int i = 0; i < N; i++) {
            for(int j = 1; j <= nums[i] && i + j < N; j++) {
                dp[i + j] = min(dp[i + j], 1 + dp[i]);
            }
        }
        
        return dp[N - 1];
    }
};
```

## 43. Count Good Nodes In Binary Tree

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int ans = 0;
    int dfs(TreeNode* root, int maxVal) {
        if(root->val >= maxVal) {
            ans++;
        }
        maxVal = max(maxVal, root->val);
        
        if(root->left) {
            dfs(root->left, maxVal);
        }
        
        if(root->right) {
            dfs(root->right, maxVal);
        }
        
        return ans;
    }
    int goodNodes(TreeNode* root) {
        return dfs(root, INT_MIN);
    }
};
```

## 44. Unique Paths

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n + 1, 0);
        dp[n - 1] = 1;
        
        for(int i = m - 1; i >= 0; i--) {
            for(int j = n - 1; j >= 0; j--){
                dp[j] += dp[j + 1];
            }
        }
        
        return dp[0];
    }
};
```

## 45. Coin Change

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int dp[amount + 1];
        dp[0] = 0;
        
        sort(coins.begin(), coins.end());
        
        for(int i = 1; i <= amount; i++) {
            
            dp[i] = INT_MAX;
            for(auto &coin : coins) {
                if(i - coin < 0) break;
                
                if(dp[i - coin] != INT_MAX) {
                    dp[i] = min(dp[i], 1 + dp[i - coin]);
                }
            }
        }
        
        if(dp[amount] != INT_MAX) {
            return dp[amount];
        } else {
            return -1;
        }
    }
};
```

## 46. Is Graph Bipartite ?

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    bool isBipartite(vector<vector<int>>& G) {
        int N = G.size();
        vector<int> id(N); // 0 unseen, 1 and -1 are different colors
        function<bool(int, int)> dfs = [&](int u, int color) {
            if (id[u]) return id[u] == color;
            id[u] = color;
            for (int v : G[u]) {
                if (!dfs(v, -color)) return false;
            }
            return true;
        };
        for (int i = 0; i < N; ++i) {
            if (!id[i] && !dfs(i, 1)) return false;
        }
        return true;
    }
};
```

## 47. Frequency of Most Frequent Elements

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int maxFrequency(vector<int>& A, int k) {
        int N = A.size();
        
        sort(A.begin(), A.end());
        
        long ans = 1, sum = 0, i = 0;
        
        for(int j = 0; j < N; j++) {
            sum += A[j];
            
            // Increase the left boundary of window :
            // (Length of window * currentElement) - Sum of all elements > k 
            while( (j - i + 1) * A[j] - sum > k) {
                sum -= A[i++];
            }
            
            ans = max(ans, j - i + 1);
            
        }
        
        return ans;
    }
};
```

## 48. Group Anagrams

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        
        unordered_map<string, vector<string>> M;
        
        for(string &s : strs) {
            
            string t = s;
            sort(t.begin(), t.end());
            
            M[t].push_back(s);
        }
        
        vector<vector<string>> ans;
        
        for(auto &[s, vs] : M) {
            ans.push_back(vs);    
        }
        
        return ans;
    }
};
```

## 49. Satisfiability of Equality Equations

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class UnionFind {
    private:
        vector<int> id, rank;
        int cnt;
    public:
        UnionFind(int cnt) : cnt(cnt) {
            id = vector<int>(cnt);
            rank = vector<int>(cnt, 0);
            for (int i = 0; i < cnt; ++i) id[i] = i;
        }
        int find(int p) {
            if (id[p] == p) return p;
            return id[p] = find(id[p]);
        }
        int getCount() { 
            return cnt; 
        }
        bool connected(int p, int q) { 
            return find(p) == find(q); 
        }
        void connect(int p, int q) {
            int i = find(p), j = find(q);
            if (i == j) return;
            if (rank[i] < rank[j]) {
                id[i] = j;  
            } else {
                id[j] = i;
                if (rank[i] == rank[j]) rank[j]++;
            }
            --cnt;
        }
};

class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        int N = equations.size();
        
        UnionFind uf(26);
        
        for(auto &e : equations) {
            if(e[1] == '=') {
                int num1 = e[0] - 'a';
                int num2 = e[3] - 'a';
                uf.connect(num1, num2);
            }
        }
        
        for(auto &e : equations) {
            if(e[1] == '!') {
                int num1 = e[0] - 'a';
                int num2 = e[3] - 'a';
                if(uf.connected(num1, num2)) {
                    return false;
                }
            }
        }
        
        return true;
    }
};
```

## 50. Range Sum BST

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int sum = 0;
    
    void preorder(TreeNode* root, int L, int R) {
        if(!root) {
            return;
        }
        
        if(root->val >= L && root->val <= R) {
            sum += root->val;
        }
        
        preorder(root->left, L, R);
        preorder(root->right, L, R);
    }
    
    int rangeSumBST(TreeNode* root, int low, int high) {
        preorder(root, low, high);
        return sum;
    }
};
```

## 51. Number of Islands

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    
    int M, N;
    
    int dirs[4][2] = { {0, 1}, {1, 0}, {-1, 0}, {0, -1}};
    
    void dfs(vector<vector<char>> &grid, int i, int j) {
        
        // This cell of grid has been visited.
        grid[i][j] = '2';
        
        // Go to the four sides of grid.
        for(auto &dir : dirs) {
            int a = i + dir[0];
            int b = j + dir[1];
            
            if(a < 0 || b < 0 || a >= M || b >= N || grid[a][b] != '1') continue;
            
            dfs(grid, a, b);
        }
    }
    
    int numIslands(vector<vector<char>>& grid) {
        M = grid.size();
        N = grid[0].size();
        
        int islandCnt = 0;
        
        for(int i = 0; i < M; i++) {
            for(int j = 0; j < N; j++) {
                if(grid[i][j] == '1') {
                    dfs(grid, i, j);
                    islandCnt++;
                }
            }
        }
        
        return islandCnt;
    }
};
```

## 52. Wildcard Matching

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    
    int M, N;
    vector<vector<int>> dp;
    
    bool wildcardMatching(string &s, string &p, int i, int j) {
        
        if(dp[i][j] != -1) return dp[i][j]; 
        int &ans = dp[i][j];
        
        for(; j < N; j++) {
            
            if(p[j] != '*' && i >= M) return ans = false;
            if(p[j] == '?') {
                i++;
            } else if(p[j] == '*') {
                while(j + 1 < N && p[j + 1] == '*') j++;
                for(int k = 0; i + k <= M; i++) {
                    if(wildcardMatching(s, p, i + k, j + 1)) {
                        return ans = true;
                    }
                }
            } else if(s[i++] != p[j]) {
                return ans = false;
            }
        }
        
        return ans = i >= M;
        
    }
    
    bool isMatch(string s, string p) {
        M = s.size();
        N = p.size();
        
        dp.assign(M + 1, vector<int>(N + 1, -1));
        return wildcardMatching(s, p, 0, 0);
    }
};
```

## 53. Min Stack

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class MinStack {
public:
    
    stack<int> S, M;
    
    void push(int val) {
        S.push(val);
        if(M.empty() || M.top() >= val) {
            M.push(val);
        }
    }
    
    void pop() {
        int x = S.top();
        S.pop();
        
        // If popped element is minimum
        if(M.top() == x) {
            M.pop();
        }
    }
    
    int top() {
        return S.top();
    }
    
    int getMin() {
        return M.top();
    }
};
```

## 54. Permutations

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    
    vector<vector<int>> ans;
    
    void permute(vector<int> &nums, int start) {
        // Base case
        if(start == nums.size()) {
            ans.push_back(nums);
            return;
        }
        
        for(int i = start; i < nums.size(); i++) {
            swap(nums[start], nums[i]);
            permute(nums, start + 1);
            swap(nums[start], nums[i]);
        }
        
    }
    
    vector<vector<int>> permute(vector<int>& nums) {
        permute(nums, 0);
        return ans;
    }
};
```

## 55. Combinations

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    
    vector<vector<int>> ans;
    
    void combine(vector<int> &temp, int n, int k, int start) {
        // Base case
        if(temp.size() == k) {
            ans.push_back(temp);
            return;
        }
        
        for(int i = start, end = n - k + temp.size(); i <= end; i++) {
            temp.push_back(i + 1);
            combine(temp, n, k, i + 1);
            temp.pop_back();
        }
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<int> temp;
        combine(temp, n, k, 0);
        return ans;
    }
};
```

## 56. Diameter of Binary Tree

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int diameter = 0;

    int dfs(TreeNode* root) {
        if(!root) {
            return 0;
        }
        
        int left = dfs(root->left);
        int right = dfs(root->right);
        
        diameter = max(diameter, left + right);
        
        return (1 + max(left, right));
    }
    
    int diameterOfBinaryTree(TreeNode* root) {
        dfs(root);
        return diameter;
    }
};
```

## 57. Peak Index In Mountain Array

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int peakIndexInMountainArray(vector<int>& arr) {
    int N = arr.size();
    
    int L = 1, R = N - 2, M;
    
    while(L <= R) {
        M = (L + R) / 2;
        
        if(arr[M] > arr[M - 1]) {
            L = M + 1;
        } else {
            R = M - 1;
        }
    }
    
    return R;
}
```

## 58. Maximum Depth of Binary Tree

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int maxDepth(TreeNode* root) {
    if(!root) {
        return 0;
    }
    
    return (1 + max(maxDepth(root->left), maxDepth(root->right)));
}
```

## 59. Find Minimum In Rotated Sorted Array

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int findMin(vector<int>& nums) {
    int N = nums.size();
    
    int L = 0, R = N - 1, M;
    
    while(L < R) {
        M = (L + R) / 2;
        
        if(nums[M] < nums[R]) {
            R = M;
        } else {
            L = M + 1;
        }
    }
    
    return nums[R];
}
```

## 60. Binary Tree Zigzag Level Order Traversal

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    
    vector<vector<int>> ans;
    
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        if(!root) {
            return {};
        }
        
        bool l2r = true;
        
        queue<TreeNode*> q;
        q.push({root});
        
        while(q.size()) {
            int cnt = q.size();
            
            vector<int> temp;
            
            while(cnt--) {
                auto node = q.front();
                q.pop();
                
                temp.push_back(node->val);
                
                if(node->left) {
                    q.push(node->left);
                }
                
                if(node->right) {
                    q.push(node->right);
                }
            }
            
            if(!l2r) {
                reverse(temp.begin(), temp.end());
            }
            
            l2r = !l2r;
            ans.push_back(temp);
        }
        
        return ans;
    }
};
```

## 61. Longest Substring Without Repeating Characters

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int lengthOfLongestSubstring(string s) {
    int N = s.length();
    int length = 0, i = 0;
    unordered_map<int, int> M;
    
    for(int j = 0; j < N; j++) {
        
        M[s[j]]++;
        
        // Increase the window size from left side if there are multiple characters
        while(M[s[j]] > 1) {
            M[s[i++]]--;
        }
        
        length = max(length, j - i + 1);
    }
    
    return length;
}
```

## 62. Combination Sum

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
vector<vector<int>> combinationSum(vector<int>& A, int target) {
    vector<vector<int>> ans;
    vector<int> tmp;
    sort(begin(A), end(A));
    function<void(int, int)> dfs = [&](int start, int goal) {
        if (goal == 0) {
            ans.push_back(tmp);
        }
        for (int i = start; i < A.size() && gaol - A[i] >= 0; ++i) {
            tmp.push_back(A[i]);
            dfs(i, goal - A[i]);
            tmp.pop_back();
        }
    };
    dfs(0, target);
    return ans;
}
```

## 63. N-Queens

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    vector<vector<string>> ret;
    
    bool is_valid(vector<string> &board, int row, int col) {
        
        for(int i = row; i >= 0; --i) {
            if(board[i][col] == 'Q') return false;
        }
            
        for(int i = row, j = col; i >= 0 && j >= 0; --i, --j) {
            if(board[i][j] == 'Q') return false;
        }
        
        for(int i = row, j = col; i >= 0 && j < board.size(); --i, ++j) {
            if(board[i][j] == 'Q') return false;
        }
            
        return true;
    }
    
    void dfs(vector<string> &board, int row){
        if(row == board.size()){
            ret.push_back(board);
            return;
        }
        
        for(int i=0; i < board.size(); ++i) {
            if(is_valid(board, row, i)){
                board[row][i] = 'Q';
                dfs(board, row + 1);
                board[row][i] = '.';
            }
        }
    }
    
    vector<vector<string>> solveNQueens(int n) {
        vector<string>board(n, string(n, '.'));
        dfs(board, 0);
        return ret;
    }
};
```

## 64. Subsets

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
vector<vector<int>> subsets(vector<int>& A) {
    vector<vector<int>> ans;
    vector<int> tmp;
    function<void(int)> dfs = [&](int i) {
        if (i == A.size()) {
            ans.push_back(tmp);
            return;
        }
        tmp.push_back(A[i]);
        dfs(i + 1); // Pick A[i]
        tmp.pop_back();
        dfs(i + 1); // Skip A[i]
    };
    dfs(0);
    return ans;
}
```

## 65. Pascal's Triangle

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
vector<vector<int>> generate(int numRows) {
    vector<vector<int>> ans(numRows);
    for (int i = 0; i < numRows; ++i) {
        ans[i] = vector<int>(i + 1, 1);
        for (int j = 1; j < i; ++j) ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j];
    }
    return ans;
}
```

## 66. House Robber II

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int N = nums.size();
        
        if(N == 1) return nums[0];
        
        if(N == 2) return max(nums[0], nums[1]);
        
        return max(robber(nums, 0, N - 2), robber(nums, 1, N - 1));
    }
    
    int robber(vector<int> &nums, int l, int r) {
        int pre = 0, cur = 0;
        
        for(int i = l; i <= r; i++) {
            int temp = max(pre + nums[i], cur);
            pre = cur;
            cur = temp;
        }
        
        return cur;
    }
};
```

## 67. Partition Equal Subset Sum

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    vector<vector<int>> dp;
    bool recurse(vector<int>& nums, int i, int target, vector<vector<int>> &dp) {
        if(i >= nums.size()) {
            return false;
        }
        if(target <= 0) {
            return target == 0;
        }
        if(dp[i][target] != -1) {
            return dp[i][target];
        } 
        
        return dp[i][target] = (recurse(nums, i + 1, target - nums[i], dp) || recurse(nums, i + 1, target, dp));
    }
    
    bool canPartition(vector<int>& nums) {
        
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum % 2) return false;
        sum /= 2;
        dp.assign(nums.size() + 1, vector<int>(sum + 1, -1));
        return recurse(nums, 0, sum, dp);
    }
};
```

## 68. Number of Submatrices That Sum To Target

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
        int M = matrix.size(), N = matrix[0].size(), ans = 0;
        vector<vector<int>> sum(M + 1, vector<int>(N + 1, 0));
        for (int i = 1; i <= M; ++i) {
            for (int j = 1; j <= N; ++j) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
        for (int i = 0; i < N; ++i) {
           for (int j = i + 1; j <= N; ++j) {
               unordered_map<int, int> m {{ 0, 1 }};
               for (int k = 1; k <= M; ++k) {
                   int val = sum[k][j] - sum[k][i];
                   ans += m[val - target];
                   m[val]++;
               }
           }
        }
        return ans;
    }
};
```

## 69. Shortest Path in Binary Matrix

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int dirs[8][2] = { {-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
    int shortestPathBinaryMatrix(vector<vector<int>>& G) {
        if (G[0][0] == 1) return -1;
        int N = G.size();
        vector<vector<int>> dist(N, vector<int>(N, INT_MAX));
        queue<pair<int, int>> q;
        q.emplace(0, 0);
        dist[0][0] = 1;
        while (q.size()) {
            auto [x, y] = q.front();
            q.pop();
            for(int i = 0; i < 8; i++) {
                int a = x + dirs[i][0];
                int b = y + dirs[i][1];
                if (a < 0 || a >= N || b < 0 || b >= N || G[a][b] == 1 || dist[a][b] != INT_MAX) continue;
                dist[a][b] = dist[x][y] + 1;
                q.emplace(a, b);
            }
        }
        return dist[N - 1][N - 1] == INT_MAX ? -1 : dist[N - 1][N - 1];
    }
};
```

## 70.Validate Binary Search Tree

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root, TreeNode* left = NULL, TreeNode* right = NULL) {
        if(!root) {
            return true;
        }
        
        if(left && root->val <= left->val || right && root->val >= right->val) {
            return false;
        }
        
        return (isValidBST(root->left, left, root) && isValidBST(root->right, root, right));
    }
};
```

## 71. Reverse Nodes in k-Group

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode h, *tail = &h;
        while (head) {
            auto prev = tail;
            int i = 0;
            for (auto p = head; i < k && p; ++i, p = p->next);
            if (i < k) {
                tail->next = head;
                break;
            }
            for (int i = 0; i < k && head; ++i) {
                auto node = head;
                head = head->next;
                node->next = prev->next;
                prev->next = node;
            }
            while (tail->next) tail = tail->next;
        }
        return h.next;
    }
};
```

## 72. Trapping Rain Water

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int trap(vector<int>& A) {
        int N = A.size(), ans = 0;
        vector<int> left(N, 0), right(N, 0);
        for (int i = 1; i < N; ++i) left[i] = max(left[i - 1], A[i - 1]);
        for (int i = N - 2; i >= 0; --i) right[i] = max(right[i + 1], A[i + 1]);
        for (int i = 1; i < N - 1; ++i) ans += max(0, min(left[i], right[i]) - A[i]);
        return ans;
    }
};
```

## 73. Find Missing Positive

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int firstMissingPositive(vector<int>& A) {
    int i, N = A.size();
    for (i = 0; i < N; ) {
        if (A[i] == i + 1 || A[i] < 1 || A[i] >= N + 1 || A[i] == A[A[i] - 1]) ++i;
        else swap(A[i], A[A[i] - 1]);
    }
    for (i = 0; i < N && A[i] == i + 1; ++i);
    return i + 1;
}

int firstMissingPositive(vector<int>& nums) {
    int N = nums.size();
    // Ignore negatives and zero.
    for(int i = 0; i < N; i++) if(nums[i] <= 0) nums[i] = N + 1;
    
    // Replacing numbers with their negatives
    for(int i = 0; i < N; i++) {
        if(abs(nums[i]) <= N && nums[abs(nums[i]) - 1] > 0) {
            nums[abs(nums[i]) - 1] *= -1;
        }
    }
    
    for(int i = 0; i < N; i++) {
        if(nums[i] > 0) {
            return i + 1;
        }
    }
    
    return N + 1;
}
```

## 74. Edit Distance

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int M = word1.size();
        int N = word2.size();
        if(!M) return N;
        if(!N) return M;
        
        vector<vector<int>> dp(M + 1, vector<int>(N + 1, INT_MAX));
        
        dp[0][0] = 0;
        
        for(int i = 0; i < M; i++) {
            dp[i + 1][0] = i + 1;
        }
        
        for(int j = 0; j < N; j++) {
            dp[0][j + 1] = j + 1;
        }
        
        for(int i = 0; i < M; i++) {
            for(int j = 0; j < N; j++) {
                if(word1[i] == word2[j]) {
                    dp[i + 1][j + 1] = dp[i][j];
                } else {
                    dp[i + 1][j + 1] = 1 + min({dp[i][j], dp[i + 1][j], dp[i][j + 1]});
                }
            }
        }
        
        return dp[M][N];
    }
};
```

## 75. Climbing Stairs

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int climbStairs(int n) {
    int prev = 0, cur = 1;
    while (n--) {
        int next = cur + prev;
        prev = cur;
        cur = next;
    }
    return cur;
}
```

## 76. Shifting Letters II

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
// Solution 1 - Line Sweep
string shiftingLetters(string s, vector<vector<int>>& shifts) {
    int line[50001] = {};
    for (auto &shift : shifts) {
        line[shift[0]] += shift[2] ? 1 : -1;
        line[shift[1] + 1] += shift[2] ? -1 : 1;
    }
    for (int i = 0, val = 0; i < s.size(); ++i) {
        val = (val + line[i]) % 26;
        s[i] = 'a' + (26 + (s[i] - 'a') + val) % 26;
    }
    return s;
}

// Solution 2 - Fenwick Tree
constexpr int static n = 50000;
int bt[n + 1] = {};
int prefix_sum(int i)
{
    int sum = 0;
    for (i = i + 1; i > 0; i -= i & (-i))
        sum += bt[i];
    return sum;
}
void add(int i, int val)
{
    for (i = i + 1; i <= n; i += i & (-i))
        bt[i] += val;
}
string shiftingLetters(string s, vector<vector<int>>& shifts) {
    for (auto &shift : shifts) {
        add(shift[0], shift[2] == 1 ? 1 : -1);
        add(shift[1] + 1, shift[2] == 1 ? -1 : 1);
    }
    for (int i = 0; i < s.size(); ++i)
        s[i] = 'a' + (26 + (s[i] - 'a') + prefix_sum(i) % 26) % 26;
    return s;
}

// Solution 3 - Segment Tree
class Solution {
public:
    vector<int> seg;

    void upd(int l, int r, int v, int x, int lx, int rx) {
        if(lx > r or rx < l) return;
        if(lx >= l and rx <= r) {
            seg[x] += v;
            return;
        }
        int mid = (lx + rx) / 2;
        upd(l, r, v, 2 * x + 1, lx, mid);
        upd(l, r, v, 2 * x + 2, mid + 1, rx);
    }

    int query(int i, int x, int lx, int rx) {
        if(lx == rx) return seg[x];

        int mid = (lx + rx) / 2;

        if(i <= mid)
            return seg[x] + query(i, 2 * x + 1, lx, mid);

        return seg[x] + query(i, 2 * x + 2, mid + 1, rx);
    }
    
    string shiftingLetters(string s, vector<vector<int>>& shifts) {
        long x = 1;
        while(x <= s.length()) x <<= 1;
        seg.resize(2 * x, 0);
        
        for(int i = 0; i < shifts.size(); ++i) {
            int l = shifts[i][0], r = shifts[i][1], dir;
            if(shifts[i][2] == 0) dir = -1;
            else dir = 1;
            upd(l, r, dir, 0, 0, x - 1);
        }
        
        for(int i = 0; i < s.length(); ++i) {
            int shift = query(i, 0, 0, x - 1);
            int dir = (shift > 0) ? 1 : -1;
            shift = abs(shift) % 26; 
            
            shift *= dir;
            int cur = s[i] - 'a';
            cur = (cur + shift + 26) % 26;
            s[i] = char(cur + 'a');
        }
        return s;
    }
};
```

## 77. Build A Matrix With Conditions

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {
	vector<int> order1 = topologicalSort(rowConditions, k);
	vector<int> order2 = topologicalSort(colConditions, k);
	if (order1.size() < k || order2.size() < k) return {};
	unordered_map<int, int> m;
	for (int i = 0; i < k; i++) m[order2[i]] = i;
	vector<vector<int>> ans(k, vector<int>(k, 0));
	for (int i = 0; i < k; i++)
		ans[i][m[order1[i]]] = order1[i];
	return ans;
}
vector<int> topologicalSort(vector<vector<int>> &A, int k) {
	vector<int> deg(k, 0), order;
	vector<vector<int>> graph(k, vector<int>(0));
	queue<int> q;
	for (auto &c: A) {
		graph[c[0] - 1].push_back(c[1] - 1);
		deg[c[1] - 1]++;
	}
	for(int i = 0; i < k; i++) 
		if (!deg[i]) q.push(i);
	while (!q.empty()) {
		int x = q.front(); q.pop();
		order.push_back(x + 1);
		for (int& y: graph[x]) 
			if (--deg[y] == 0) 
				q.push(y);
	}
	return order;
}
```

## 78. Serialize and Deserialize Binary Tree

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Codec {
private:
    TreeNode *getNode(vector<string> &v, int &i) {
        string s = v[i++];
        return s == "#" ? NULL : new TreeNode(stoi(s));
    }
public:
    string serialize(TreeNode* root) {
        if (!root) return "";
        queue<TreeNode*> q;
        q.push(root);
        string ans;
        while (!q.empty()) {
            root = q.front();
            q.pop();
            if (!ans.empty()) ans += ',';
            if (root) {
                ans += to_string(root->val);
                q.push(root->left);
                q.push(root->right);
            } else ans += '#';
        }
        return ans;
    }
    TreeNode* deserialize(string data) {
        if (data.empty()) return NULL;
        stringstream ss(data);
        string val;
        vector<string> v;
        while (getline(ss, val, ',')) v.push_back(val);
        TreeNode *root = new TreeNode(stoi(v[0]));
        queue<TreeNode*> q;
        q.push(root);
        int i = 1;
        while (i < v.size()) {
            TreeNode *node = q.front();
            q.pop();
            node->left = getNode(v, i);
            node->right = getNode(v, i);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        return root;
    }
};
```

## 79. Pacific Atlantic Water Flow

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
    int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}}, M, N;
    void dfs(vector<vector<int>> &A, int x, int y, vector<vector<int>> &m) {
        if (m[x][y]) return;
        m[x][y] = 1;
        for (auto &[dx, dy] : dirs) {
            int a = x + dx, b = y + dy;
            if (a < 0 || a >= M || b < 0 || b >= N || A[a][b] < A[x][y]) continue;
            dfs(A, a, b, m);
        }
    }
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& A) {
        if (A.empty() || A[0].empty()) return {};
        M = A.size(), N = A[0].size();
        vector<vector<int>> a(M, vector<int>(N)), b(M, vector<int>(N)), ans; 
        for (int i = 0; i < M; ++i) {
            dfs(A, i, 0, a);
            dfs(A, i, N - 1, b);
        }
        for (int j = 0; j < N; ++j) {
            dfs(A, 0, j, a);
            dfs(A, M - 1, j, b);
        }
        for (int i = 0; i < M; ++i) {
            for (int j = 0; j < N; ++j) {
                if (a[i][j] && b[i][j]) ans.push_back({i, j});
            }
        }
        return ans;
    }
};
```

## 80. Delete and Earn

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int deleteAndEarn(vector<int>& nums) {
    vector<int> dp(10002, 0);
    vector<int> sum(10002, 0);
    
    for(auto a : nums) {
        sum[a] += a;
    }
    
    dp[0] = sum[0];
    dp[1] = sum[1];
    
    for(int i = 2; i < 10001; i++) {
        dp[i] = max(dp[i - 1], dp[i - 2] + sum[i]);
    }
    
    return dp[10000];
}
```

## 81. Permutations II

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    vector<vector<int>> ans;
    void permute(vector<int> nums, int start) {
        if(start == nums.size() - 1) {
            ans.push_back(nums);
            return;
        }
        
        for(int i = start; i < nums.size(); i++) {
            if(i != start && nums[i] == nums[start]) continue;
            swap(nums[i], nums[start]);
            permute(nums, start + 1);
        }
    }
    
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        permute(nums, 0);
        return ans;
    }
};
```

## 82. Combination Sum II

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& A, int target) {
        
        int N = A.size();
        sort(A.begin(), A.end());
        vector<vector<int>> ans;
        vector<int> temp;
        
        function<void(int, int)> dfs = [&](int start, int goal) {
            if(goal == 0) {
                ans.push_back(temp);
                return;
            }
            
            for(int i = start; i < N && goal - A[i] >= 0 ; i++) {
                if(i != start && A[i] == A[i - 1]) continue;
                temp.push_back(A[i]);
                dfs(i + 1, goal - A[i]);
                temp.pop_back();
            }
        };
        
        dfs(0, target);
        
        return ans;
    }
};
```

## 83. Non Overlapping Intervals

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int eraseOverlapIntervals(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end(), [](auto &a, auto &b) {
        return a[1] < b[1];
    });
    
    int overlapCnt = 0;
    int end = INT_MIN;
    
    for(auto &e : intervals) {
        if(e[0] >= end) {
            end = e[1];
        } else {
            overlapCnt++;
        }
    }
    
    return overlapCnt;
}
```

## 84. Best Time To Buy and Sell Stocks With Cooldown

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    int maxProfit(vector<int>& A) {
        if (A.empty()) return 0;
        int N = A.size(), buy = INT_MIN;
        vector<int> dp(N + 1, 0);
        for (int i = 0; i < N; ++i) {
            buy = max(buy, (i >= 1 ? dp[i - 1] : 0) - A[i]);
            dp[i + 1] = max(dp[i], buy + A[i]);
        }
        return dp[N];
    }
};
```

## 85. Maximum XOR of Two Numbers In An Array

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
// Using Bitmasks
class Solution {
public:
    int findMaximumXOR(vector<int>& A) {
        unordered_set<int> s;
        int mask = 0, ans = 0;
        for (int i = 31; i >= 0; --i) {
            mask |= 1 << i;
            s.clear();
            for (int n : A) s.insert(n & mask);
            int next = ans | (1 << i);
            for (int prefix : s) {
                if (!s.count(next ^ prefix)) continue;
                ans |= 1 << i;
                break;
            }
        }
        return ans;
    }
};


// Using Trie
struct TrieNode {
    TrieNode *next[2] = {};
};
class Solution {
    void add(TrieNode *node, int n) {
        for (int i = 31; i >= 0; --i) {
            int b = n >> i & 1;
            if (node->next[b] == NULL) node->next[b] = new TrieNode();
            node = node->next[b];
        }
    }
    int maxXor(TrieNode *node, int n) {
        int ans = 0;
        for (int i = 31; i >= 0; --i) {
            int b = n >> i & 1;
            if (node->next[1 - b]) { // if we can go the opposite direction, do it.
                node = node->next[1 - b];
                ans |= 1 << i;
            } else {
                node = node->next[b];
            }
        }
        return ans;
    }
public:
    int findMaximumXOR(vector<int>& A) {
        TrieNode root;
        int ans = 0;
        for (int n : A) {
            add(&root, n);
            ans = max(ans, maxXor(&root, n));
        }
        return ans;
    }
};
```

## 86. Implement Queue Using Stacks

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class MyQueue {
public:
    
    stack<int> S1, S2;
    
    void push(int x) {
        while(!S1.empty()) {
            S2.push(S1.top());
            S1.pop();
        }
        
        S2.push(x);
        
        while(!S2.empty()) {
            S1.push(S2.top());
            S2.pop();
        }
    }
    
    int pop() {
        int x = S1.top();
        S1.pop();
        
        return x;
    }
    
    int peek() {
        return S1.top();
    }
    
    bool empty() {
        return S1.empty();
    }
};
```

## 87. Minimum Size Subarray Sum 

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
int minSubArrayLen(int target, vector<int>& nums) {   
    int N = nums.size();
    int i = 0, sum = 0, ans = INT_MAX;
    
    for(int j = 0; j < N; j++) {
        sum += nums[j];
        
        while(sum >= target) {
            if(sum >= target) {
                ans = min(ans, j - i + 1);
            }
            sum -= nums[i++];
        }  
    }
    
    return ans == INT_MAX ? 0 : ans;
}
```

## 88. Number of Visible People In A Queue

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
vector<int> canSeePersonsCount(vector<int>& A) {
    stack<int> S;
    int N = A.size();
    vector<int> ans(N, 0);
    
    for(int i = 0; i < N; i++) {
        // Monotonically Increasing Sequence
        while(S.size() && A[S.top()] <= A[i]) {
            ans[S.top()]++;
            S.pop();
        }
        
        if(S.size()) {
            ans[S.top()]++;
        }
        
        S.push(i);
    }    
    return ans;    
}
```

## 89. Describe The Painting 

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    vector<vector<long long>> splitPainting(vector<vector<int>>& segments) {
        long long line[200001] = {};
        bool change[200001] = {};
        
        int maxEnd = -1;
        
        for(auto &e : segments) {
            int start = e[0], end = e[1], value = e[2];
            line[start] += value;
            line[end] -= value;
            change[start] = change[end] = true;
            maxEnd = max(maxEnd, end);
        }
        
        for(int i = 1; i <= maxEnd; i++) {
            line[i] += line[i - 1];
        }
        
        vector<vector<long long>> ans;
        
        for(int i = 0; i <= maxEnd;) {
            int start = i;
            while(i <= maxEnd && line[i] == line[start] && (i == start || !change[i])) i++;
            
            if(line[start]) {
                ans.push_back({start, i, line[start]});
            }
        }
        
        return ans;
    }
};
```

## 90. Flood Fill

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


```cpp
class Solution {
public:
    
    int dirs[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
    int M, N, startingColor;
    
    void dfs(vector<vector<int>> &image, int x, int y, int C) {
        
        image[x][y] = C;
        
        for(auto &dir : dirs) {
            int a = x + dir[0];
            int b = y + dir[1];
            
            if(a < 0 || b < 0 || a >= M || b >= N || image[a][b] != startingColor) continue;
            
            dfs(image, a, b, C);
        }
    }
    
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        M = image.size();
        N = image[0].size();
        
        startingColor = image[sr][sc];
        
        if(color == startingColor) {
            return image;
        }
        
        dfs(image,  sr, sc, color);
        
        return image;
    }
};
```

## 91. Palindrome Partitioning

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    
    bool isPalindrome(string &s, int i, int j) {
        while(i < j && s[i] == s[j]) {
            i++;
            j--;
        }
        return i >= j;
    }
    
    vector<vector<string>> ans;
    vector<string> temp;
    
    void dfs(string &s, int start) {
        if(start == s.size()) {
            ans.push_back(temp);
            return;
        }
        
        for(int i = start; i < s.length(); i++) {
            if(!isPalindrome(s, start, i)) continue;
            
            temp.push_back(s.substr(start, i - start + 1));
            dfs(s, i + 1);
            temp.pop_back();
        }
    }
    
    vector<vector<string>> partition(string s) {
        dfs(s, 0);
        return ans;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 92. Path With Maximum Gold

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int M, N;
    int dirs[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
    int maxGold = 0;
    
    
    void dfs(vector<vector<int>>& grid, int x, int y, int cnt) {
        
        // Store gold in current cell.
        int gold = grid[x][y];
        grid[x][y] = 0;
        
        cnt += gold;
        maxGold = max(maxGold, cnt);
        
        for(auto &dir : dirs) {
            int a = x + dir[0];
            int b = y + dir[1];
            
            if(a < 0 || b < 0 || a >= M || b >= N || grid[a][b] == 0) continue;
            
            dfs(grid, a, b, cnt);
        }
        
        grid[x][y] = gold;
    }
    
    int getMaximumGold(vector<vector<int>>& grid) {
        M = grid.size();
        N = grid[0].size();
        
        for(int i = 0; i < M; i++) {
            for(int j = 0; j < N; j++) {
                if(grid[i][j] == 0) continue;
                dfs(grid, i, j, 0);
            }
        }
        
        return maxGold;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 93. Counting Bits

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<int> countBits(int N) {
        vector<int> dp(N + 1);
        
        dp[0] = 0;
        
        for(int i = 1; i <= N; i++) {
            dp[i] = dp[i / 2] + (i & 1);
        }
        
        return dp;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 94. Word Break

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        
        unordered_set<string> M(wordDict.begin(), wordDict.end());
        
        int N = s.size();
        vector<bool> dp(N + 1);
        dp[0] = true;
        
        for(int i = 1; i <= N; i++) {
            for(int j = 0; j < i && !dp[i]; j++) {
                dp[i] = dp[j] && M.count(s.substr(j, i - j));
            }
        }
        
        return dp[N];
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 95. Find Median From Data Stream

<details>
<summary> View Code </summary>

```cpp
class MedianFinder {
public:
    priority_queue<int, vector<int>, greater<int>> maxHeap;
    priority_queue<int, vector<int>> minHeap;
    
    void addNum(int num) {
        if(minHeap.empty()) {
            minHeap.push(num);
        } else if(num < minHeap.top()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
            minHeap.push(num);
        } else {
            maxHeap.push(num);
        }
        
        while(maxHeap.size() > minHeap.size()) {
            minHeap.push(maxHeap.top());
            maxHeap.pop();
        }
    }
    
    double findMedian() {
        if(maxHeap.size() == minHeap.size()) {
            return (double)(maxHeap.top() + minHeap.top()) / 2;
        } else {
            return (double)(minHeap.top());
        }
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 96. Single Threaded CPU

<details>
<summary> View Code </summary>

```cpp
class Solution {
    typedef pair<int, int> T;
public:
    vector<int> getOrder(vector<vector<int>>& A) {
        priority_queue<T, vector<T>, greater<>> pq;
        long N = A.size(), time = 0, i = 0;
        for (int i = 0; i < N; ++i) A[i].push_back(i);
        sort(begin(A), end(A));
        vector<int> ans;
        while (i < N || pq.size()) { 
            if (pq.empty()) {
                time = max(time, (long)A[i][0]);
            }
            while (i < N && time >= A[i][0]) {
                pq.emplace(A[i][1], A[i][2]);
                ++i;
            }
            auto [pro, index] = pq.top();
            pq.pop();
            time += pro;
            ans.push_back(index);
        }
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 97. Contiguous Array

<details>
<summary> View Code </summary>

```cpp
int findMaxLength(vector<int>& A) {
    unordered_map<int, int> m{{0,-1}};
    int ans = 0;
    for (int i = 0, sum = 0; i < A.size(); ++i) {
        sum += A[i] ? 1 : -1;
        if (m.count(sum)) ans = max(ans, i - m[sum]);
        else m[sum] = i;
    }
    return ans;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 98. Falling Squares
<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
  int n;
  vector<int> height, lazy;

  void push_up(int i) {
    height[i] = max(height[i*2], height[i*2+1]);
  }

  void push_down(int i) {
    if (lazy[i]) {
        lazy[i*2] = lazy[i*2+1] = lazy[i];
        height[i*2] = height[i*2+1] = lazy[i];
        lazy[i] = 0;
    }
  }

  void update(int i, int l, int r, int L, int R, int val) {
    if (L <= l && r <= R) {
      height[i] = val;
      lazy[i] = val;
      return;
    }
    push_down(i);
    int mid = l + (r-l)/2;
    if (L < mid) update(i*2, l, mid, L, R, val);
    if (R > mid) update(i*2+1, mid, r, L, R, val);
    push_up(i);
  }

  int query(int i, int l, int r, int L, int R) {
    if (L <= l && r <= R) return height[i];
    push_down(i);
    int res = 0;;
    int mid = l + (r-l)/2;
    if (L < mid) res = max(res, query(i*2, l, mid, L, R));
    if (R > mid) res = max(res, query(i*2+1, mid, r, L, R));
    return res;
  }

  vector<int> fallingSquares(vector<pair<int, int>>& positions) {
    vector<int> a;
    for (auto& p : positions) {
      a.push_back(p.first);
      a.push_back(p.first+p.second);
    }
    sort(a.begin(), a.end());
    n = unique(a.begin(), a.end()) - a.begin();
    a.resize(n);
    
    height.resize(n<<2, 0);
    lazy.resize(n<<2, 0);
    vector<int> res;
    for (auto& p : positions) {
      int l = lower_bound(a.begin(), a.end(), p.first) - a.begin();
      int r = lower_bound(a.begin(), a.end(), p.first+p.second) - a.begin();
      int maxh = query(1, 0, n, l, r);
      update(1, 0, n, l, r, maxh+p.second);
      res.push_back(query(1, 0, n, 0, n));
    }
    return res;
  }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 99. Minimum XOR Sum of Two Arrays

<details>
<summary> View Code </summary>

```cpp
class Solution {
    int dp[15][17000];
    int recursion(vector<int> &nums1, vector<int>&nums2, int i, int mask) {
        
        if(i >= nums1.size()) return 0;
        if(dp[i][mask] != -1) return dp[i][mask];
        
        int ans = INT_MAX;

        for(int j = 0; j < nums2.size(); j++) {
            if(mask & (1 << j)) continue;
            int val = nums1[i] ^ nums2[j];

            ans = min(ans, recursion(nums1, nums2, i + 1, mask | (1 << j)) + val);
        }

        return dp[i][mask] = ans;
    }

public:
    int minimumXORSum(vector<int>& nums1, vector<int>& nums2) {
        memset(dp, -1, sizeof(dp));
        return recursion(nums1, nums2, 0, 0);
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 100. Maximum Profit In Job Scheduling

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        vector<array<int, 3>> jobs;
        for (int i = 0; i < startTime.size(); ++i) jobs.push_back({ startTime[i], endTime[i], profit[i] });
        sort(begin(jobs), end(jobs), greater<>());
        map<int, int> dp{{INT_MAX, 0}};
        int ans = 0;
        for (auto &[s, e, p] : jobs) {
            dp[s] = max(ans, p + dp.lower_bound(e)->second);
            ans = max(ans, dp[s]);
        }
        return ans;
    }
};

```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 101. Find Minimum Time To Finish All Jobs

<details>
<summary> View Code </summary>

```cpp
int dp[13][1 << 12], sum[1 << 12];
class Solution {
public:
    int minimumTimeRequired(vector<int>& A, int k) {
        int N = A.size();
        memset(dp, 0x3f, sizeof(dp));
        memset(sum, 0, sizeof(sum));
        for (int i = 0; i <= k; ++i) dp[i][0] = 0;
        for (int mask = 0; mask < (1 << N); ++mask) {
            for (int i = 0; i < N; ++i) {
                if (mask & (1 << i)) sum[mask] += A[i];
            }
        }
        for (int i = 0; i < k; ++i) {
            for (int mask = 0; mask < (1 << N); ++mask) {
                for (int sub = mask; sub; sub = (sub - 1) & mask) {
                    dp[i + 1][mask] = min(dp[i + 1][mask], max(dp[i][mask ^ sub], sum[sub]));
                }
            }
        }
        return dp[k][(1 << N) - 1];
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 102. Course Schedule

<details>
<summary> View Code </summary>

```cpp
bool canFinish(int n, vector<vector<int>>& E) {
    vector<vector<int>> G(n);
    vector<int> indegree(n);
    for (auto &e : E) {
        G[e[1]].push_back(e[0]);
        ++indegree[e[0]];
    }
    queue<int> q;
    for (int i = 0; i < n; ++i) {
        if (indegree[i] == 0) q.push(i);
    }
    while (q.size()) {
        int u = q.front();
        q.pop();
        --n;
        for (int v : G[u]) {
            if (--indegree[v] == 0) q.push(v);
        }
    }
    return n == 0;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 103. Minimum Height Trees

<details>
<summary> View Code </summary>

```cpp
vector<int> findMinHeightTrees(int n, vector<vector<int>>& E) {
    if (n == 1) return { 0 };
    vector<int> degree(n), ans;
    vector<vector<int>> G(n);
    for (auto &e : E) {
        int u = e[0], v = e[1];
        degree[u]++;
        degree[v]++;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    queue<int> q;
    for (int i = 0; i < n; ++i) {
        if (degree[i] == 1) q.push(i);
    }
    while (n > 2) {
        int cnt = q.size();
        n -= cnt;
        while (cnt--) {
            int u = q.front();
            q.pop();
            for (int v : G[u]) {
                if (--degree[v] == 1) q.push(v);
            }
        }
    }
    while (q.size()) {
        ans.push_back(q.front());
        q.pop();
    }
    return ans;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 104. Russian Doll Envelopes

<details>
<summary> View Code </summary>

```cpp
int maxEnvelopes(vector<vector<int>>& A) {
    sort(begin(A), end(A), [](auto &a, auto &b) { return a[0] != b[0] ? a[0] < b[0] : a[1] > b[1]; });
    vector<int> dp;
    for (auto &v : A) {
        auto it = lower_bound(begin(dp), end(dp), v[1]);
        if (it == end(dp)) dp.push_back(v[1]);
        else *it = v[1];
    }
    return dp.size();
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 105. Maximum AND Sum of Array

<details>
<summary> View Code </summary>

```cpp
int maximumANDSum(vector<int>& A, int numSlots) {
    A.resize(2 * numSlots); // append 0s to make sure the length of `A` is `2 * numSlots`
    int N = A.size();
    vector<int> dp(1 << N);
    for (int m = 1; m < 1 << N; ++m) {
        int cnt = __builtin_popcount(m), slot = (cnt + 1) / 2; 
        for (int i = 0; i < N; ++i) {
            if (m >> i & 1) { // we assign A[i] to `slot`-th slot
                dp[m] = max(dp[m], dp[m ^ (1 << i)] + (slot & A[i]));
            }
        }
    }
    return dp[(1 << N) - 1];
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 106. Maximum Number of Robots Within Budget

<details>
<summary> View Code - Sliding Window </summary>

```cpp

```
</details>

<details>
<summary> View Code - Sparse Table and Binary Search </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 107. Find Longest Awesome Substring

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 108. Maximum Rows Covered By Columns

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 109. Create Sorted Array Through Instructions

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 110. Maximum Students Taking Exam

<details>
<summary> View Code </summary>

```cpp

```
</details>

<br>[⬆ Back to top](#table-of-contents)