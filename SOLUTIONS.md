# Table of Contents
- [Table of Contents](#table-of-contents)
  - [1. Longest Increasing Subsequence](#1-longest-increasing-subsequence)
  - [2. Generate Parentheses](#2-generate-parentheses)
  - [3. Sort Array By Parity](#3-sort-array-by-parity)
  - [4. Min Cost To Connect All Points](#4-min-cost-to-connect-all-points)
  - [5. Power(x, n)](#5-powerx-n)
  - [6. Critical Connections In A Network](#6-critical-connections-in-a-network)
  - [7. Longest Increasing Path In A Matrix](#7-longest-increasing-path-in-a-matrix)
  - [8. Valid Arrangement of Pairs](#8-valid-arrangement-of-pairs)
  - [9. Next Greater Element II](#9-next-greater-element-ii)
  - [10. Container With Most Water](#10-container-with-most-water)
  - [11. Implement Trie (Prefix Tree)](#11-implement-trie-prefix-tree)
  - [12. Sort The Matrix Diagonally](#12-sort-the-matrix-diagonally)
  - [13. Minimum Window Substring](#13-minimum-window-substring)
  - [14. Increasing Triplet Subsequence](#14-increasing-triplet-subsequence)
  - [15. Target Sum](#15-target-sum)
  - [16. Check If There Is A Valid Partition For The Array](#16-check-if-there-is-a-valid-partition-for-the-array)
  - [17. Longest Consecutive Sequence](#17-longest-consecutive-sequence)
  - [18. Valid Sudoku](#18-valid-sudoku)
  - [19. My Calendar I](#19-my-calendar-i)
  - [20. Sliding Window Maximum](#20-sliding-window-maximum)
  - [21. Best Time To Buy and Sell Stock](#21-best-time-to-buy-and-sell-stock)
  - [22. Maximum Subarray](#22-maximum-subarray)
  - [23. Cracking The Safe](#23-cracking-the-safe)
  - [24. Find If Path Exists In Graph](#24-find-if-path-exists-in-graph)
  - [25. Next Greater Node In Linked List](#25-next-greater-node-in-linked-list)
  - [26. Repeated Substring Pattern](#26-repeated-substring-pattern)
  - [27. Search Suggestion System](#27-search-suggestion-system)
  - [28. Merge K Sorted Lists](#28-merge-k-sorted-lists)
  - [29. Daily Temperatures](#29-daily-temperatures)
  - [30. Merge Intervals](#30-merge-intervals)
  - [31. Word Ladder](#31-word-ladder)
  - [32. 3Sum](#32-3sum)
  - [33. Flatten Binary Tree To Linked List](#33-flatten-binary-tree-to-linked-list)
  - [34. Sum of Subarray Minimums](#34-sum-of-subarray-minimums)
  - [35. Median of Two Sorted Arrays](#35-median-of-two-sorted-arrays)
  - [36. LRU Cache](#36-lru-cache)
  - [37. Gas Station](#37-gas-station)
  - [38. Max Points On A Line](#38-max-points-on-a-line)
  - [39. Largest Rectangle In Histogram](#39-largest-rectangle-in-histogram)
  - [40. Regular Expression Matching](#40-regular-expression-matching)
  - [41. Minimum Deletions To Make Character Frequencies Unique](#41-minimum-deletions-to-make-character-frequencies-unique)
  - [42. Jump Game II](#42-jump-game-ii)
  - [43. Count Good Nodes In Binary Tree](#43-count-good-nodes-in-binary-tree)
  - [44. Unique Paths](#44-unique-paths)
  - [45. Coin Change](#45-coin-change)
  - [46. Is Graph Bipartite ?](#46-is-graph-bipartite-)
  - [47. Frequency of Most Frequent Elements](#47-frequency-of-most-frequent-elements)
  - [48. Group Anagrams](#48-group-anagrams)
  - [49. Satisfiability of Equality Equations](#49-satisfiability-of-equality-equations)
  - [50. Range Sum BST](#50-range-sum-bst)
  - [51. Number of Islands](#51-number-of-islands)
  - [52. Wildcard Matching](#52-wildcard-matching)
  - [53. Min Stack](#53-min-stack)
  - [54. Permutations](#54-permutations)
  - [55. Combinations](#55-combinations)
  - [56. Diameter of Binary Tree](#56-diameter-of-binary-tree)
  - [57. Peak Index In Mountain Array](#57-peak-index-in-mountain-array)
  - [58. Maximum Depth of Binary Tree](#58-maximum-depth-of-binary-tree)
  - [59. Find Minimum In Rotated Sorted Array](#59-find-minimum-in-rotated-sorted-array)
  - [60. Binary Tree Zigzag Level Order Traversal](#60-binary-tree-zigzag-level-order-traversal)
  - [61. Longest Substring Without Repeating Characters](#61-longest-substring-without-repeating-characters)
  - [62. Combination Sum](#62-combination-sum)
  - [63. N-Queens](#63-n-queens)
  - [64. Subsets](#64-subsets)
  - [65. Pascal's Triangle](#65-pascals-triangle)
  - [66. House Robber II](#66-house-robber-ii)
  - [67. Partition Equal Subset Sum](#67-partition-equal-subset-sum)
  - [68. Number of Submatrices That Sum To Target](#68-number-of-submatrices-that-sum-to-target)
  - [69. Shortest Path in Binary Matrix](#69-shortest-path-in-binary-matrix)
  - [70.Validate Binary Search Tree](#70validate-binary-search-tree)
  - [71. Reverse Nodes in k-Group](#71-reverse-nodes-in-k-group)
  - [72. Trapping Rain Water](#72-trapping-rain-water)
  - [73. Find Missing Positive](#73-find-missing-positive)
  - [74. Edit Distance](#74-edit-distance)
  - [75. Climbing Stairs](#75-climbing-stairs)
  - [76. Shifting Letters II](#76-shifting-letters-ii)
  - [77. Build A Matrix With Conditions](#77-build-a-matrix-with-conditions)
  - [78. Serialize and Deserialize Binary Tree](#78-serialize-and-deserialize-binary-tree)
  - [79. Pacific Atlantic Water Flow](#79-pacific-atlantic-water-flow)
  - [80. Delete and Earn](#80-delete-and-earn)
  - [81. Permutations II](#81-permutations-ii)
  - [82. Combination Sum II](#82-combination-sum-ii)
  - [83. Non Overlapping Intervals](#83-non-overlapping-intervals)
  - [84. Best Time To Buy and Sell Stocks With Cooldown](#84-best-time-to-buy-and-sell-stocks-with-cooldown)
  - [85. Maximum XOR of Two Numbers In An Array](#85-maximum-xor-of-two-numbers-in-an-array)
  - [86. Implement Queue Using Stacks](#86-implement-queue-using-stacks)
  - [87. Minimum Size Subarray Sum](#87-minimum-size-subarray-sum)
  - [88. Number of Visible People In A Queue](#88-number-of-visible-people-in-a-queue)
  - [89. Describe The Painting](#89-describe-the-painting)
  - [90. Flood Fill](#90-flood-fill)
  - [91. Palindrome Partitioning](#91-palindrome-partitioning)
  - [92. Path With Maximum Gold](#92-path-with-maximum-gold)
  - [93. Counting Bits](#93-counting-bits)
  - [94. Word Break](#94-word-break)
  - [95. Find Median From Data Stream](#95-find-median-from-data-stream)
  - [96. Single Threaded CPU](#96-single-threaded-cpu)
  - [97. Contiguous Array](#97-contiguous-array)
  - [98. Falling Squares](#98-falling-squares)
  - [99. Minimum XOR Sum of Two Arrays](#99-minimum-xor-sum-of-two-arrays)
  - [100. Maximum Profit In Job Scheduling](#100-maximum-profit-in-job-scheduling)
  - [101. Find Minimum Time To Finish All Jobs](#101-find-minimum-time-to-finish-all-jobs)
  - [102. Course Schedule](#102-course-schedule)
  - [103. Minimum Height Trees](#103-minimum-height-trees)
  - [104. Russian Doll Envelopes](#104-russian-doll-envelopes)
  - [105. Maximum AND Sum of Array](#105-maximum-and-sum-of-array)
  - [106. Maximum Number of Robots Within Budget](#106-maximum-number-of-robots-within-budget)
  - [107. Find Longest Awesome Substring](#107-find-longest-awesome-substring)
  - [108. Maximum Rows Covered By Columns](#108-maximum-rows-covered-by-columns)
  - [109. Create Sorted Array Through Instructions](#109-create-sorted-array-through-instructions)
  - [110. Maximum Students Taking Exam](#110-maximum-students-taking-exam)
  - [111. Number of Ways To Reach A Position After Exactly K Steps](#111-number-of-ways-to-reach-a-position-after-exactly-k-steps)
  - [112. Find The Longest Substring Containing Vowels In Even Counts](#112-find-the-longest-substring-containing-vowels-in-even-counts)
  - [113. Maximum Earnings From Taxi](#113-maximum-earnings-from-taxi)
  - [114. Vertical Order Traversal Of A Binary Tree](#114-vertical-order-traversal-of-a-binary-tree)
  - [115. Invert Binary Tree](#115-invert-binary-tree)
  - [116. Count Primes](#116-count-primes)
  - [117. Find The Shortest Superstring](#117-find-the-shortest-superstring)
  - [118. Sum Root To Leaf Nodes](#118-sum-root-to-leaf-nodes)
  - [119. Longest Common Subsequence](#119-longest-common-subsequence)
  - [120. Count Number of Maximum Bitwise Or Subsets](#120-count-number-of-maximum-bitwise-or-subsets)
  - [121. Jump Game III](#121-jump-game-iii)
  - [122. Operations on Tree](#122-operations-on-tree)
  - [123. Minimum Operations To Convert Number](#123-minimum-operations-to-convert-number)
  - [124. Egg Drop With 2 Eggs and N Floors](#124-egg-drop-with-2-eggs-and-n-floors)
  - [125. Problem Name](#125-problem-name)

## 1. Longest Increasing Subsequence

<details>
<summary> Solution - DP </summary>

```cpp
int lengthOfLIS(vector<int>& nums) {
    int N = nums.size();
    
    vector<int> dp;
    
    for(int i = 0; i < N; i++) {
        
        auto it = lower_bound(dp.begin(), dp.end(), nums[i]);
        
        if(it != dp.end()) {
            *it = nums[i];
        } else {
            dp.push_back(nums[i]);
        }
    }
    
    return dp.size();
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 2. Generate Parentheses

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    
    vector<string> ans;
    
    void backtracking(string &temp, int leftCnt, int rightCnt) {
        
        // We found a valid parentheses.
        if(leftCnt == 0 && rightCnt == 0) {
            ans.push_back(temp);
            return;
        }
        
        // Include left parentheses
        
        if(leftCnt) {
            temp += "(";
            backtracking(temp, leftCnt - 1, rightCnt);
            temp.pop_back();
        }
        
        // Include right parentheses
        
        if(rightCnt > leftCnt) {
            temp += ")";
            backtracking(temp, leftCnt, rightCnt - 1);
            temp.pop_back();
        }
        
    }
    
    vector<string> generateParenthesis(int n) {
        string temp = "";
        backtracking(temp, n, n);
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 3. Sort Array By Parity

<details>
<summary> View Code </summary>

```cpp
vector<int> sortArrayByParity(vector<int>& A) {
    sort(A.begin(), A.end(), [](int a, int b) {
        return a % 2 < b % 2;
    });
    
    return A;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 4. Min Cost To Connect All Points

<details>
<summary> View Code </summary>

```cpp
class UnionFind {
    private:
        vector<int> id, rank;
        int cnt;
    public:
        UnionFind(int cnt) : cnt(cnt) {
            id = vector<int>(cnt);
            rank = vector<int>(cnt, 0);
            for (int i = 0; i < cnt; ++i) id[i] = i;
        }
        int find(int p) {
            if (id[p] == p) return p;
            return id[p] = find(id[p]);
        }
        int getCount() { 
            return cnt; 
        }
        bool connected(int p, int q) { 
            return find(p) == find(q); 
        }
        void connect(int p, int q) {
            int i = find(p), j = find(q);
            if (i == j) return;
            if (rank[i] < rank[j]) {
                id[i] = j;  
            } else {
                id[j] = i;
                if (rank[i] == rank[j]) rank[j]++;
            }
            --cnt;
        }
};

class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        
        int N = points.size();
        
        vector<array<int, 3>> E;
        
        for(int i = 0; i < N; i++) {
            for(int j = i + 1; j < N; j++) {
                E.push_back({abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]), i, j});
            }
        }
        
        UnionFind uf(N);
        
        int ans = 0;
        
        // How to convert vector into heap.
        make_heap(E.begin(), E.end(), greater<array<int, 3>>());
        
        while(uf.getCount() > 1) {
            pop_heap(E.begin(), E.end(), greater<array<int, 3>>());
            auto [w, u, v] = E.back();
            
            E.pop_back();
            
            if(uf.connected(u, v)) continue;
            
            uf.connect(u, v);
            ans += w;
        }
        
        return ans;
        
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 5. Power(x, n)

<details>
<summary> View Code </summary>

```cpp
double recursion(double x, long n) {
        
    if(n < 0) {
        return 1 / recursion(x, -n);
    }
    
    if(n == 0) {
        return 1;
    }
    
    if(n == 1) {
        return x;
    }
    
    if(n == 2) {
        return x * x;
    }
    
    return recursion( recursion (x, n / 2), 2) * (n % 2 ? x : 1);
}

double myPow(double x, int n) {
    return recursion(x, (long)n);
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 6. Critical Connections In A Network

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
        vector<int> ranks(n, INT_MIN);
        
        vector<vector<int>> G(n), ans;
        
        for(auto &e : connections) {
            int u = e[0], v = e[1];
            G[u].push_back(v);
            G[v].push_back(u);
        }
        
        function<int(int, int)> dfs = [&](int u, int rank) {
            if(ranks[u] >= 0) return ranks[u];
            
            ranks[u] = rank;
            int minRank = rank;
            
            for(int v : G[u]) {
                
                if(ranks[v] >= rank - 1) continue; 
                
                int neighbourMinRank = dfs(v, rank + 1);
                minRank = min(minRank, neighbourMinRank);
                
                if (neighbourMinRank > rank) {
                    ans.push_back({u, v});
                }
            }
            
            return minRank;
        };
        
        
        dfs(0, 0);
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 7. Longest Increasing Path In A Matrix

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int M, N;
    vector<vector<int>> cnt;
    
    int dirs[4][2] = { {1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    
    int dfs(vector<vector<int>> &A, int i, int j) {
        
        if(cnt[i][j] != -1e9) {
            return cnt[i][j];
        }
        
        cnt[i][j] = 1;
        
        for(auto &dir : dirs) {
            int a = i + dir[0];
            int b = j + dir[1];
            
            if(a < 0 || b < 0 || a >= M || b >= N || A[a][b] <= A[i][j]) continue;
            
            cnt[i][j] = max(cnt[i][j] , 1 + dfs(A, a, b));
        }
        
        return cnt[i][j];
    }
    
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        M = matrix.size();
        N = matrix[0].size();
        
        cnt.assign(M, vector<int>(N, -1e9));
        
        int ans = 0;
        
        for(int i = 0; i < M; i++) {
            for(int j = 0; j < N; j++) {
                ans = max(ans, dfs(matrix, i, j));
            }
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 8. Valid Arrangement of Pairs

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {
        unordered_map<int, vector<int>> G;
        unordered_map<int, int> indegrees, outdegrees;
        
        for(auto &e : pairs) {
            int u = e[0], v = e[1];
            G[u].push_back(v);
            indegrees[v]++;
            outdegrees[u]++;
        }
        
        // Select the starting node.
        int start = -1;
        
        for(auto &[u, ad] : G ) {
            if(outdegrees[u] - indegrees[u] == 1) {
                start = u;
                break;
            }
        }
        
        if(start == -1) {
            start = pairs[0][0];
        }
        
        vector<vector<int>> ans;
        
        function<void(int)> euler = [&](int u) {
            
            auto &ad = G[u];
            
            while(ad.size()) {
                int v = ad.back();
                ad.pop_back();
                
                euler(v);
                ans.push_back({u, v});
            }
        };
        
        euler(start);
        reverse(ans.begin(), ans.end());
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 9. Next Greater Element II

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        int N = nums.size();
        
        // Stores index.
        stack<int> S;
        
        // Stores element
        vector<int> ans(N, -1);
        
        for(int i = 0; i < 2 * N; i++) {
            
            int n = nums[i % N];
            
            while(S.size() && nums[S.top()] < n) {
                ans[S.top()] = n;
                S.pop();
            }
            
            S.push(i % N);
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 10. Container With Most Water

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        
        int N = height.size();
        int L = 0, R = N - 1;
        
        int ans = 0;
        
        while(L < R) {
            int area = min(height[L], height[R]) * (R - L);
            
            ans = max(ans, area);
            
            if(height[L] < height[R]) {
                L++;
            } else {
                R--;
            }
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 11. Implement Trie (Prefix Tree)

<details>
<summary> View Code </summary>

```cpp
struct TrieNode {
    TrieNode *next[26] = {};
    bool word = false;
};

class Trie {
    
    TrieNode root;
    
    TrieNode *find(string s) {
        
        auto node = &root;
        
        for(char c : s) {
            if(!node->next[c - 'a']) return NULL;
            
            node = node->next[c - 'a'];
        }
        
        return node;
    }
    
public:
    
    void insert(string word) {
        
        auto node = &root;
        
        for(char c : word) {
            if(!node->next[c - 'a']) node->next[c - 'a'] = new TrieNode();
            
            node = node->next[c - 'a'];
        }
        
        node->word = true;
    }
    
    bool search(string word) {
        auto wordFind = find(word);
        return wordFind && (wordFind->word == true);
    }
    
    bool startsWith(string prefix) {
        return find(prefix);
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)



## 12. Sort The Matrix Diagonally

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {
        int M = mat.size();
        int N = mat[0].size();
        
        for (int i = 0; i < M; ++i) {
            vector<int> v;
            for (int x = i, y = 0; x < M && y < N; ++x, ++y) {
                v.push_back(mat[x][y]);
            }
            sort(v.begin(), v.end());
            int index = 0;
            for (int x = i, y = 0; x < M && y < N; ++x, ++y) {
                mat[x][y] = v[index++];
            }
        }
        
         for (int j = 1; j < N; ++j) {
             vector<int> v;
             for(int x = 0, y = j; x < M && y < N; ++x, ++y) {
                 v.push_back(mat[x][y]);
             }
             sort(v.begin(), v.end());
             int index = 0;
             for (int x = 0, y = j; x < M && y < N; ++x, ++y) {
                 mat[x][y] = v[index++];
             }
         }
        
        return mat;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 13. Minimum Window Substring

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        
        unordered_map<char, int> target, cnt;
        int N = s.length();
        
        // Store the frequency of target string
        for(char c : t) {
            target[c]++;
        }
        
        int matched = 0;
        int start = 0, len = INT_MAX;
        int i = 0;
        
        // Traverse the s string, j - right boundary, left boundary - 0
        for(int j = 0; j < N; j++) {
            
            if(++cnt[s[j]] <= target[s[j]]) matched++;
            
            // Target string comes inside this window substring.
            while(matched == t.size()) {
                
                // Update the answer start and its length
                if(len > j - i + 1) {
                    len = j - i + 1;
                    start = i;
                }
                
                // Decrease the length of window.
                if(--cnt[s[i]] < target[s[i]]) matched--;
                i++;
            }
            
        }
        
        if(len == INT_MAX) {
            return "";
        } else {
            return s.substr(start, len);
        }
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 14. Increasing Triplet Subsequence

<details>
<summary> View Code </summary>


```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        
        int N = nums.size();
        
        vector<int> dp;
        
        for(int i = 0; i < N; i++) {
            
            auto it = lower_bound(dp.begin(), dp.end(), nums[i]);
            
            if(it != dp.end()) {
                *it = nums[i];
            } else {
                dp.push_back(nums[i]);
            }
        }
        
        return (dp.size() >= 3);
        
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 15. Target Sum

<details>
<summary> Solution - Recursion (TLE) </summary>

```cpp
class Solution {
public:
    
    int recur(vector<int>& nums, int sum, int target, int i) {
        int n = nums.size();
        
        if(n == i) {
            // Check the sum if it is equal to target
            if(sum == target) return 1;
            
            return 0;
        }
        
        int res = 0;
        
        // Include
        res += recur(nums, sum + nums[i], target, i + 1);
        
        // Not Include
        res += recur(nums, sum - nums[i], target, i + 1);
        
        return res;
        
    }
    
    int findTargetSumWays(vector<int>& nums, int target) {
        // (vector, sum, target, index);
        return recur(nums, 0, target, 0);
    }
};
```
</details>

<details>
<summary> Solution - DP </summary>

```cpp
class Solution {
public:
    int recursion(vector<int>& nums, int sum, int target, int i, vector<vector<int>> &dp) {
        
        if(i == nums.size()) {
            return sum == target;
        }
        
        if(dp[i][sum + 1000] != -1) return dp[i][sum + 1000];
        
        
        int include = recursion(nums, sum + nums[i], target, i + 1, dp);
        int notInclude = recursion(nums, sum - nums[i], target, i + 1, dp);
        
        dp[i][sum + 1000] = include + notInclude;
        
        return dp[i][sum + 1000];
    }   
    
    int findTargetSumWays(vector<int>& nums, int target) {
        vector<vector<int>> dp(nums.size() + 1, vector<int>(3000, -1));
        return recursion(nums, 0, target, 0, dp);
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 16. Check If There Is A Valid Partition For The Array

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    bool validPartition(vector<int>& nums) {
        int N = nums.size();
        bool dp[N + 1];
        
        for(int i = 0; i <= N; i++) dp[i] = false;
        
        dp[0] = true;
        
        for(int i = 0; i < N; i++) {
            // for two elements
            if(i >= 1) {
                if(dp[i - 1] && nums[i] == nums[i - 1]) {
                    dp[i + 1] = true;
                }
            }
            
            // for three elements
            if(i >= 2) {
                if(dp[i - 2] && nums[i] == nums[i - 1] && nums[i - 1] == nums[i - 2]) {
                    dp[i + 1] = true;
                }
            }
            
            // for three consecutive elements
            if(i >= 2) {
                if(dp[i - 2] && nums[i] == nums[i - 1] + 1 && nums[i - 1] == nums[i - 2] + 1) {
                    dp[i + 1] = true;
                }
            }
        }
        
        return dp[N];
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 17. Longest Consecutive Sequence

<details>
<summary> View Code </summary>

```cpp
// Union Find that also return the vector of size of components.
class UnionFind {
    vector<int> id, size;
public:
    UnionFind(int n) : id(n), size(n, 1) {
        for (int i = 0; i < n; ++i) id[i] = i;
    }
    void connect(int a, int b) {
        int x = find(a), y = find(b);
        if (x == y) return;
        id[x] = y;
        size[y] += size[x];
    }
    int find(int a) {
        return id[a] == a ? a : (id[a] = find(id[a]));
    }
    vector<int> &getSizes() {
        return size;
    }
};

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        
        int N = nums.size();
        
        if(N == 0) {
            return 0;
        }
        
        UnionFind uf(N);
        
        unordered_map<int, int> M;
        
        // We have to store indexes in UnionFind instead of integer values.
        
        for(int i = 0; i < N; i++) {
            int n = nums[i];
            
            if(M.count(n)) continue;
            
            M[n] = i;
            
            if(M.count(n - 1)) uf.connect(M[n], M[n - 1]);
            if(M.count(n + 1)) uf.connect(M[n], M[n + 1]);
        }
        
        // ans -> maximum component size
        vector<int> ans = uf.getSizes();
        return *max_element(ans.begin(), ans.end());
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 18. Valid Sudoku

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int row[9][9] = {}, col[9][9] = {}, box[9][9] = {};
        
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                int n = board[i][j] - '1';
                
                if(board[i][j] == '.') continue;
                
                if(row[i][n] || col[j][n] || box[(i / 3) * 3 + (j / 3)][n]) return false;
                
                
                row[i][n] = col[j][n] = box[i / 3 * 3 + j / 3][n] = 1;
            }
        }
        
        return true;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 19. My Calendar I

<details>
<summary> View Code </summary>


```cpp
class MyCalendar {
public:
    MyCalendar() {
        
    }

    map<int, int> M;
    
    bool book(int start, int end) {
        
        if(M.empty()) {
            M[start] = end;
            return true;
        }
        
        // Conditions 
        
        auto it = M.upper_bound(start);
        
        // Check the later intersection
        if(it != M.end() && it->first < end) return false;
        
        // Check the starting intersection
        if(it != M.begin() && prev(it)->second > start) return false;
        
        
        // After checking conditions
        M[start] = end;
        return true;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 20. Sliding Window Maximum

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int N = nums.size();
        deque<int> d; // Deque will store the index
        
        vector<int> ans;
        
        for(int i = 0; i < N; i++) {
            
            int n = nums[i];
            
            // When the element goes out of window, remove from the deque.
            if(d.size() && d.front() == i - k) d.pop_front();
            
            // We have to store monotonically decreasing sequence.
            while(d.size() && nums[d.back()]  <= n) {
                d.pop_back();
            }
            
            d.push_back(i);
            
            if(i >= k - 1) {
                // Push maximum element in answer.
                ans.push_back(nums[d.front()]);
            }
            
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 21. Best Time To Buy and Sell Stock

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int N = prices.size();
        
        int minStock = prices[0];
        int profit = 0;
        
        for(int i = 0; i < N; i++) {
            minStock = min(minStock, prices[i]);
            
            profit = max(profit, prices[i] - minStock);
        }
        
        return profit;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 22. Maximum Subarray

<details>
<summary> View Code </summary>

```cpp
int maxSubArray(vector<int>& nums) {
    int global = nums[0];
    int local = 0;
    
    int N = nums.size();
    
    for(int i = 0; i < N; i++) {
        local = max(local + nums[i], nums[i]);
        global = max(global, local);
    }
    
    return global;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 23. Cracking The Safe

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    string crackSafe(int n, int k) {
        
        if(n == 1 && k == 1) return "0";
        
        // Store the edges of graph.
        unordered_set<string> M; 
        
        string start = string(n - 1, '0');
        string ans = "";
        
        function<void(string)> euler = [&](string u) {      
            for(char c = '0'; c < k + '0'; c++) {
                // How to use the last sequence optimally
                string v = u + c;

                // We don't have to visit the same edge again
                if(M.count(v)) continue;
                M.insert(v);
                
                euler(v.substr(1));

                ans.push_back(c);
            }
        };
        
        euler(start);
        
        return ans + start;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 24. Find If Path Exists In Graph

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        
        // Creation of Graph
        unordered_map<int, vector<int>> G;
        
        for(auto &e : edges) {
            int u = e[0], v = e[1];
            G[u].push_back(v);
            G[v].push_back(u);
        }
        
        // BFS
        
        queue<int> q;
        vector<int> seen(n, 0); // 0 ->unseen
        
        q.push(source);
        seen[source] = 1;
        
        while(q.size()) {
            int v = q.front();
            q.pop();
            // Traverse every edge of v in breadth first search
            
            for(int u : G[v]) {
                if(seen[u]) continue;
                seen[u] = 1;
                q.push(u);
            }
        }
        
        if(seen[destination] == 1) {
            return true;
        } else {
            return false;
        }
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 25. Next Greater Node In Linked List

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = new ListNode();
        
        while(head) {
            auto node = head;
            head = head->next;
            node->next = prev->next;
            prev->next = node;
        }

        return prev->next;
    }
    
    vector<int> nextLargerNodes(ListNode* head) {
        head = reverseList(head);
        
        stack<int> S;
        vector<int> ans;
        
        
        while(head) {
            
            int n = head->val;
            
            while(S.size() && S.top() <= n) {
                S.pop();
            }
            
            if(S.size() == 0) {
                ans.push_back(0);
            } else {
                ans.push_back(S.top());
            }
            
            S.push(n);
            
            head = head->next;
        }
        
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 26. Repeated Substring Pattern

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        int N = s.length();
        
        for(int len = 1; len <= N / 2; len++) {
            if(N % len) continue;
            
            int i = len;
            for(; i < N; i++) {
                if( s[i] != s[i % len]) break;
            }
            
            if(i == N) return true;
        }
        
        return false;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 27. Search Suggestion System

<details>
<summary> View Code </summary>

```cpp
struct TrieNode {
    TrieNode *next[26] = {};
    int index = -1;
};

void add(TrieNode *node, string &s, int i) {
    
    for(char c: s) {
        if(!node->next[c - 'a']) node->next[c - 'a'] = new TrieNode();
        node = node->next[c - 'a'];
    }
    node->index = i;
}

void collect(TrieNode *node, vector<string> &ans, vector<string> &products) {
    if(ans.size() == 3) return;
    
    if(!node) return;
    
    if(node->index > -1) ans.push_back(products[node->index]);
    
    for(int i = 0; i < 26; i++) {
        if(node->next[i]) collect(node->next[i], ans, products);
    }
}

class Solution {
public:
    vector<vector<string>> suggestedProducts(vector<string>& products, string searchWord) {
        TrieNode root, *node = &root;
        
        for(int i = 0; i < products.size(); i++) {
            add(&root, products[i], i);
        }
        
        vector<vector<string>> ans(searchWord.size());
        
        for(int i = 0; i < searchWord.length(); i++) {
            node = node->next[searchWord[i] - 'a'];
            
            if(!node) break;
            
            collect(node, ans[i], products);
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 28. Merge K Sorted Lists

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode dummy, *tail = &dummy;
        auto cmp = [](auto a, auto b) { return a->val > b->val; };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> q(cmp);
        for (auto list : lists) {
            if (list) q.push(list); // avoid pushing NULL list.
        }
        while (q.size()) {
            auto node = q.top();
            q.pop();
            if (node->next) q.push(node->next);
            tail->next = node;
            tail = node;
        }
        return dummy.next;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 29. Daily Temperatures

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& A) {
        stack<int> s;
        vector<int> ans(A.size());
        for (int i = A.size() - 1; i >= 0; --i) {
            while (s.size() && A[s.top()] <= A[i]) s.pop();
            ans[i] = s.size() ? s.top() - i : 0;
            s.push(i);
        }
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 30. Merge Intervals

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        
        sort(intervals.begin(), intervals.end());
        vector<vector<int>> ans;
        
        for(auto &a : intervals) {
            if(!ans.size() || a[0] > ans.back()[1]) {
                ans.push_back(a);
            } else if(ans.back()[1] < a[1]) {
                ans.back()[1] = a[1];
            }
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 31. Word Ladder

<details>
<summary> View Code </summary>

```cpp
int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
    unordered_set<string> s(begin(wordList), end(wordList));
    if (s.count(endWord) == 0) return 0;
    queue<string> q{{beginWord}};
    s.erase(beginWord);
    int step = 1;
    while (q.size()) {
        int cnt = q.size();
        while (cnt--) {
            auto u = q.front();
            q.pop();
            if (u == endWord) return step;
            for (char &c : u) { // add unvisited neighbors of `u`
                char tmp = c;
                for (char ch = 'a'; ch <= 'z'; ++ch) {
                    if (tmp == ch) continue;
                    c = ch;
                    if (s.count(u) == 0) continue;
                    s.erase(u);
                    q.push(u);
                }
                c = tmp;
            }
        }
        ++step;
    }
    return 0;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 32. 3Sum

<details>
<summary> View Code </summary>

```cpp
vector<vector<int>> threeSum(vector<int>& A) {
    vector<vector<int>> ans;
    sort(A.begin(), A.end());
    
    int N = A.size();
    int L = 0, R = N - 1;
    
    for(int i = 0; i < N - 2; i++) {
        
        if(i > 0 && A[i] == A[i - 1]) continue;
        
        int L = i + 1, R = N - 1;
        
        while(L < R) {
            int sum = A[i] + A[L] + A[R];
            
            if(sum == 0) {
                ans.push_back({A[i], A[L], A[R]});
            }
            
            if(sum <= 0) {
                L++;

                while(L < R && A[L] == A[L - 1]) L++;
            }
            
            if(sum >= 0) {
                R--;

                while(L < R && A[R] == A[R + 1]) R--;
            }
        }
    }
    
    return ans;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 33. Flatten Binary Tree To Linked List

<details>
<summary> View Code </summary>

```cpp
void flatten(TreeNode* root) {
    if(!root) return;
    TreeNode *tail = nullptr;
    
    stack<TreeNode*> S;
    
    S.push({root});
    
    while(S.size()) {
        auto node = S.top();
        S.pop();
        
        if(tail) tail->right = node;
        tail = node;
        
        if(node->right) S.push(node->right);
        if(node->left) S.push(node->left);
        
        node->left = node->right = nullptr;
    }
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 34. Sum of Subarray Minimums

<details>
<summary> View Code </summary>

```cpp
int sumSubarrayMins(vector<int>& A) {
    stack<int> q;
    q.push(-1);
    long N = A.size(), ans = 0, sum = 0, mod = 1e9+7;
    for (int i = 0; i < N; ++i) {
        sum = (sum + A[i]) % mod;
        while (q.top() != -1 && A[q.top()] >= A[i]) {
            int j = q.top();
            q.pop();
            int c = j - q.top();
            sum = (sum + c * (A[i] - A[j]) % mod) % mod;
        }
        q.push(i);
        ans = (ans + sum) % mod;
    }
    return ans;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 35. Median of Two Sorted Arrays

<details>
<summary> View Code </summary>

```cpp
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.size() > nums2.size()) swap(nums1, nums2);
    int M = nums1.size(), N = nums2.size(), L = 0, R = M, K = (M + N + 1) / 2;
    while (true) {
        int i = (L + R) / 2, j = K - i;
        if (i < M && nums2[j - 1] > nums1[i]) L = i + 1;
        else if (i > L && nums1[i - 1] > nums2[j]) R = i - 1;
        else {
            int maxLeft = max(i ? nums1[i - 1] : INT_MIN, j ? nums2[j - 1] : INT_MIN);
            if ((M + N) % 2) return maxLeft;
            int minRight = min(i == M ? INT_MAX : nums1[i], j == N ? INT_MAX : nums2[j]);
            return (maxLeft + minRight) / 2.0;
        }
    }
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 36. LRU Cache

<details>
<summary> View Code </summary>

```cpp
class LRUCache {
    int capacity;
    list<pair<int, int>> data;
    unordered_map<int, list<pair<int, int>>::iterator> m;
    void moveToFront(int key) {
        auto node = m[key];
        data.splice(data.begin(), data, node);
        m[key] = data.begin();
    }
public:
    LRUCache(int capacity) : capacity(capacity) {}
    int get(int key) {
        // get node given key, put the node at the beginning of the list, return the value in the node
        if (m.count(key)) {
            moveToFront(key);
            return m[key]->second;
        }
        return -1;
    }
    void put(int key, int value) {
        // if key exists in the map, get node given key, put the node at the beginning of the list and update the value in the node
        // otherwise, put a new node at the beginning of the list with the <key, value> and update the map. If capacity exceeded, remove the last node from the list and map.
        if (m.count(key)) {
            moveToFront(key);
            m[key]->second = value;
        } else {
            data.emplace_front(key, value);
            m[key] = data.begin();
            if (data.size() > capacity) {
                m.erase(data.rbegin()->first);
                data.pop_back();
            }
        }
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 37. Gas Station

<details>
<summary> View Code </summary>

```cpp
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    int N = gas.size(), len = 0, start = 0;
    for (int i = 0, sum = 0; i < 2 * N && len < N; ++i) {
        sum += gas[i % N] - cost[i % N];
        if (sum < 0) {
            len = sum = 0;
            start = (i + 1) % N;
        } else ++len;
    }
    return len == N ? start : -1;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 38. Max Points On A Line

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {
        
        int res = 0;
        for(int i = 0; i<points.size(); i++){
            
            unordered_map<long double,int> noOfPointsInLine;
            
            for(int j = i + 1; j < points.size(); j++){
                
                int x1 = points[i][0], y1 = points[i][1], x2 = points[j][0], y2 = points[j][1];
                
                if(y2 == y1) {     
                    noOfPointsInLine[INT_MIN]++;
                } else if(x1 == x2){ 
                    noOfPointsInLine[INT_MAX]++;
                } else {               
                    long double slope = (long double)(y2 - y1) /(long double)(x2 - x1);
                    noOfPointsInLine[slope]++;
                }
                
            }
            
            for(auto i : noOfPointsInLine){
                res = max(i.second, res);
            }
        }
        return res + 1;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 39. Largest Rectangle In Histogram

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& A) {
        int N = A.size();
        
        int ans = 0;
        
        stack<int> S;
        vector<int> next(N, N), prev(N, -1);
        
        for(int i = 0; i < N; i++) {
            while(S.size() && A[i] < A[S.top()]) {
                next[S.top()] = i;
                S.pop();
            }
            S.push(i);
        }
        
        for(int i = N - 1; i >= 0; i--) {
            while(S.size() && A[i] < A[S.top()]) {
                prev[S.top()] = i;
                S.pop();
            }
            S.push(i);
        }
        
        for(int i = 0; i < N; i++) {
            ans = max(ans, A[i] * (next[i] - prev[i] - 1));
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 40. Regular Expression Matching

<details>
<summary> View Code </summary>

```cpp
class Solution {
private:
    inline bool matchChar(string &s, int i, string &p, int j) {
        return p[j] == '.' ? i < s.size() : s[i] == p[j];
    }
    bool isMatch(string s, int i, string p, int j) {
        if (j == p.size()) return i == s.size();
        if (j + 1 < p.size() && p[j + 1] == '*') {
            bool ans = false;
            while (!(ans = isMatch(s, i, p, j + 2))
            && matchChar(s, i, p, j)) ++i;
            return ans;
        } else {
            return matchChar(s, i, p, j) && isMatch(s, i + 1, p, j + 1);
        }
    }
public:
    bool isMatch(string s, string p) {
        return isMatch(s, 0, p, 0);
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 41. Minimum Deletions To Make Character Frequencies Unique

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int minDeletions(string s) {
        int cnt[26] = {0};
        set<int> S;
        int ans = 0;
        for (char c : s) {
          cnt[c - 'a']++;  
        } 
        
        for(int i = 0; i < 26; i++) {
            while(cnt[i]-- && !S.insert(cnt[i]).second) {
                ans++;
            }
        }
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 42. Jump Game II

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int N = nums.size();
        vector<int> dp(N, 1e9);
        
        dp[0] = 0;
        
        for(int i = 0; i < N; i++) {
            for(int j = 1; j <= nums[i] && i + j < N; j++) {
                dp[i + j] = min(dp[i + j], 1 + dp[i]);
            }
        }
        
        return dp[N - 1];
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 43. Count Good Nodes In Binary Tree

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int ans = 0;
    int dfs(TreeNode* root, int maxVal) {
        if(root->val >= maxVal) {
            ans++;
        }
        maxVal = max(maxVal, root->val);
        
        if(root->left) {
            dfs(root->left, maxVal);
        }
        
        if(root->right) {
            dfs(root->right, maxVal);
        }
        
        return ans;
    }
    int goodNodes(TreeNode* root) {
        return dfs(root, INT_MIN);
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 44. Unique Paths

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n + 1, 0);
        dp[n - 1] = 1;
        
        for(int i = m - 1; i >= 0; i--) {
            for(int j = n - 1; j >= 0; j--){
                dp[j] += dp[j + 1];
            }
        }
        
        return dp[0];
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 45. Coin Change

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int dp[amount + 1];
        dp[0] = 0;
        
        sort(coins.begin(), coins.end());
        
        for(int i = 1; i <= amount; i++) {
            
            dp[i] = INT_MAX;
            for(auto &coin : coins) {
                if(i - coin < 0) break;
                
                if(dp[i - coin] != INT_MAX) {
                    dp[i] = min(dp[i], 1 + dp[i - coin]);
                }
            }
        }
        
        if(dp[amount] != INT_MAX) {
            return dp[amount];
        } else {
            return -1;
        }
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 46. Is Graph Bipartite ?

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    bool isBipartite(vector<vector<int>>& G) {
        int N = G.size();
        vector<int> id(N); // 0 unseen, 1 and -1 are different colors
        function<bool(int, int)> dfs = [&](int u, int color) {
            if (id[u]) return id[u] == color;
            id[u] = color;
            for (int v : G[u]) {
                if (!dfs(v, -color)) return false;
            }
            return true;
        };
        for (int i = 0; i < N; ++i) {
            if (!id[i] && !dfs(i, 1)) return false;
        }
        return true;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 47. Frequency of Most Frequent Elements

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int maxFrequency(vector<int>& A, int k) {
        int N = A.size();
        
        sort(A.begin(), A.end());
        
        long ans = 1, sum = 0, i = 0;
        
        for(int j = 0; j < N; j++) {
            sum += A[j];
            
            // Increase the left boundary of window :
            // (Length of window * currentElement) - Sum of all elements > k 
            while( (j - i + 1) * A[j] - sum > k) {
                sum -= A[i++];
            }
            
            ans = max(ans, j - i + 1);
            
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 48. Group Anagrams

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        
        unordered_map<string, vector<string>> M;
        
        for(string &s : strs) {
            
            string t = s;
            sort(t.begin(), t.end());
            
            M[t].push_back(s);
        }
        
        vector<vector<string>> ans;
        
        for(auto &[s, vs] : M) {
            ans.push_back(vs);    
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 49. Satisfiability of Equality Equations

<details>
<summary> View Code </summary>

```cpp
class UnionFind {
    private:
        vector<int> id, rank;
        int cnt;
    public:
        UnionFind(int cnt) : cnt(cnt) {
            id = vector<int>(cnt);
            rank = vector<int>(cnt, 0);
            for (int i = 0; i < cnt; ++i) id[i] = i;
        }
        int find(int p) {
            if (id[p] == p) return p;
            return id[p] = find(id[p]);
        }
        int getCount() { 
            return cnt; 
        }
        bool connected(int p, int q) { 
            return find(p) == find(q); 
        }
        void connect(int p, int q) {
            int i = find(p), j = find(q);
            if (i == j) return;
            if (rank[i] < rank[j]) {
                id[i] = j;  
            } else {
                id[j] = i;
                if (rank[i] == rank[j]) rank[j]++;
            }
            --cnt;
        }
};

class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        int N = equations.size();
        
        UnionFind uf(26);
        
        for(auto &e : equations) {
            if(e[1] == '=') {
                int num1 = e[0] - 'a';
                int num2 = e[3] - 'a';
                uf.connect(num1, num2);
            }
        }
        
        for(auto &e : equations) {
            if(e[1] == '!') {
                int num1 = e[0] - 'a';
                int num2 = e[3] - 'a';
                if(uf.connected(num1, num2)) {
                    return false;
                }
            }
        }
        
        return true;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 50. Range Sum BST

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int sum = 0;
    
    void preorder(TreeNode* root, int L, int R) {
        if(!root) {
            return;
        }
        
        if(root->val >= L && root->val <= R) {
            sum += root->val;
        }
        
        preorder(root->left, L, R);
        preorder(root->right, L, R);
    }
    
    int rangeSumBST(TreeNode* root, int low, int high) {
        preorder(root, low, high);
        return sum;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)


## 51. Number of Islands

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    
    int M, N;
    
    int dirs[4][2] = { {0, 1}, {1, 0}, {-1, 0}, {0, -1}};
    
    void dfs(vector<vector<char>> &grid, int i, int j) {
        
        // This cell of grid has been visited.
        grid[i][j] = '2';
        
        // Go to the four sides of grid.
        for(auto &dir : dirs) {
            int a = i + dir[0];
            int b = j + dir[1];
            
            if(a < 0 || b < 0 || a >= M || b >= N || grid[a][b] != '1') continue;
            
            dfs(grid, a, b);
        }
    }
    
    int numIslands(vector<vector<char>>& grid) {
        M = grid.size();
        N = grid[0].size();
        
        int islandCnt = 0;
        
        for(int i = 0; i < M; i++) {
            for(int j = 0; j < N; j++) {
                if(grid[i][j] == '1') {
                    dfs(grid, i, j);
                    islandCnt++;
                }
            }
        }
        
        return islandCnt;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 52. Wildcard Matching

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    
    int M, N;
    vector<vector<int>> dp;
    
    bool wildcardMatching(string &s, string &p, int i, int j) {
        
        if(dp[i][j] != -1) return dp[i][j]; 
        int &ans = dp[i][j];
        
        for(; j < N; j++) {
            
            if(p[j] != '*' && i >= M) return ans = false;
            if(p[j] == '?') {
                i++;
            } else if(p[j] == '*') {
                while(j + 1 < N && p[j + 1] == '*') j++;
                for(int k = 0; i + k <= M; i++) {
                    if(wildcardMatching(s, p, i + k, j + 1)) {
                        return ans = true;
                    }
                }
            } else if(s[i++] != p[j]) {
                return ans = false;
            }
        }
        
        return ans = i >= M;
        
    }
    
    bool isMatch(string s, string p) {
        M = s.size();
        N = p.size();
        
        dp.assign(M + 1, vector<int>(N + 1, -1));
        return wildcardMatching(s, p, 0, 0);
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 53. Min Stack

<details>
<summary> View Code </summary>

```cpp
class MinStack {
public:
    
    stack<int> S, M;
    
    void push(int val) {
        S.push(val);
        if(M.empty() || M.top() >= val) {
            M.push(val);
        }
    }
    
    void pop() {
        int x = S.top();
        S.pop();
        
        // If popped element is minimum
        if(M.top() == x) {
            M.pop();
        }
    }
    
    int top() {
        return S.top();
    }
    
    int getMin() {
        return M.top();
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 54. Permutations

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    
    vector<vector<int>> ans;
    
    void permute(vector<int> &nums, int start) {
        // Base case
        if(start == nums.size()) {
            ans.push_back(nums);
            return;
        }
        
        for(int i = start; i < nums.size(); i++) {
            swap(nums[start], nums[i]);
            permute(nums, start + 1);
            swap(nums[start], nums[i]);
        }
        
    }
    
    vector<vector<int>> permute(vector<int>& nums) {
        permute(nums, 0);
        return ans;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 55. Combinations

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    
    vector<vector<int>> ans;
    
    void combine(vector<int> &temp, int n, int k, int start) {
        // Base case
        if(temp.size() == k) {
            ans.push_back(temp);
            return;
        }
        
        for(int i = start, end = n - k + temp.size(); i <= end; i++) {
            temp.push_back(i + 1);
            combine(temp, n, k, i + 1);
            temp.pop_back();
        }
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<int> temp;
        combine(temp, n, k, 0);
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 56. Diameter of Binary Tree

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int diameter = 0;

    int dfs(TreeNode* root) {
        if(!root) {
            return 0;
        }
        
        int left = dfs(root->left);
        int right = dfs(root->right);
        
        diameter = max(diameter, left + right);
        
        return (1 + max(left, right));
    }
    
    int diameterOfBinaryTree(TreeNode* root) {
        dfs(root);
        return diameter;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 57. Peak Index In Mountain Array

<details>
<summary> View Code </summary>

```cpp
int peakIndexInMountainArray(vector<int>& arr) {
    int N = arr.size();
    
    int L = 1, R = N - 2, M;
    
    while(L <= R) {
        M = (L + R) / 2;
        
        if(arr[M] > arr[M - 1]) {
            L = M + 1;
        } else {
            R = M - 1;
        }
    }
    
    return R;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 58. Maximum Depth of Binary Tree

<details>
<summary> View Code </summary>

```cpp
int maxDepth(TreeNode* root) {
    if(!root) {
        return 0;
    }
    
    return (1 + max(maxDepth(root->left), maxDepth(root->right)));
}
```

</details>

<br>[⬆ Back to top](#table-of-contents)


## 59. Find Minimum In Rotated Sorted Array

<details>
<summary> View Code </summary>

```cpp
int findMin(vector<int>& nums) {
    int N = nums.size();
    
    int L = 0, R = N - 1, M;
    
    while(L < R) {
        M = (L + R) / 2;
        
        if(nums[M] < nums[R]) {
            R = M;
        } else {
            L = M + 1;
        }
    }
    
    return nums[R];
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 60. Binary Tree Zigzag Level Order Traversal

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    
    vector<vector<int>> ans;
    
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        if(!root) {
            return {};
        }
        
        bool l2r = true;
        
        queue<TreeNode*> q;
        q.push({root});
        
        while(q.size()) {
            int cnt = q.size();
            
            vector<int> temp;
            
            while(cnt--) {
                auto node = q.front();
                q.pop();
                
                temp.push_back(node->val);
                
                if(node->left) {
                    q.push(node->left);
                }
                
                if(node->right) {
                    q.push(node->right);
                }
            }
            
            if(!l2r) {
                reverse(temp.begin(), temp.end());
            }
            
            l2r = !l2r;
            ans.push_back(temp);
        }
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 61. Longest Substring Without Repeating Characters

<details>
<summary> View Code </summary>

```cpp
int lengthOfLongestSubstring(string s) {
    int N = s.length();
    int length = 0, i = 0;
    unordered_map<int, int> M;
    
    for(int j = 0; j < N; j++) {
        
        M[s[j]]++;
        
        // Increase the window size from left side if there are multiple characters
        while(M[s[j]] > 1) {
            M[s[i++]]--;
        }
        
        length = max(length, j - i + 1);
    }
    
    return length;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 62. Combination Sum

<details>
<summary> View Code </summary>

```cpp
vector<vector<int>> combinationSum(vector<int>& A, int target) {
    vector<vector<int>> ans;
    vector<int> tmp;
    sort(begin(A), end(A));
    function<void(int, int)> dfs = [&](int start, int goal) {
        if (goal == 0) {
            ans.push_back(tmp);
        }
        for (int i = start; i < A.size() && gaol - A[i] >= 0; ++i) {
            tmp.push_back(A[i]);
            dfs(i, goal - A[i]);
            tmp.pop_back();
        }
    };
    dfs(0, target);
    return ans;
}
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 63. N-Queens

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<vector<string>> ret;
    
    bool is_valid(vector<string> &board, int row, int col) {
        
        for(int i = row; i >= 0; --i) {
            if(board[i][col] == 'Q') return false;
        }
            
        for(int i = row, j = col; i >= 0 && j >= 0; --i, --j) {
            if(board[i][j] == 'Q') return false;
        }
        
        for(int i = row, j = col; i >= 0 && j < board.size(); --i, ++j) {
            if(board[i][j] == 'Q') return false;
        }
            
        return true;
    }
    
    void dfs(vector<string> &board, int row){
        if(row == board.size()){
            ret.push_back(board);
            return;
        }
        
        for(int i=0; i < board.size(); ++i) {
            if(is_valid(board, row, i)){
                board[row][i] = 'Q';
                dfs(board, row + 1);
                board[row][i] = '.';
            }
        }
    }
    
    vector<vector<string>> solveNQueens(int n) {
        vector<string>board(n, string(n, '.'));
        dfs(board, 0);
        return ret;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 64. Subsets

<details>
<summary> View Code </summary>

```cpp
vector<vector<int>> subsets(vector<int>& A) {
    vector<vector<int>> ans;
    vector<int> tmp;
    function<void(int)> dfs = [&](int i) {
        if (i == A.size()) {
            ans.push_back(tmp);
            return;
        }
        tmp.push_back(A[i]);
        dfs(i + 1); // Pick A[i]
        tmp.pop_back();
        dfs(i + 1); // Skip A[i]
    };
    dfs(0);
    return ans;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 65. Pascal's Triangle

<details>
<summary> View Code </summary>

```cpp
vector<vector<int>> generate(int numRows) {
    vector<vector<int>> ans(numRows);
    for (int i = 0; i < numRows; ++i) {
        ans[i] = vector<int>(i + 1, 1);
        for (int j = 1; j < i; ++j) ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j];
    }
    return ans;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 66. House Robber II

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int N = nums.size();
        
        if(N == 1) return nums[0];
        
        if(N == 2) return max(nums[0], nums[1]);
        
        return max(robber(nums, 0, N - 2), robber(nums, 1, N - 1));
    }
    
    int robber(vector<int> &nums, int l, int r) {
        int pre = 0, cur = 0;
        
        for(int i = l; i <= r; i++) {
            int temp = max(pre + nums[i], cur);
            pre = cur;
            cur = temp;
        }
        
        return cur;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 67. Partition Equal Subset Sum

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<vector<int>> dp;
    bool recurse(vector<int>& nums, int i, int target, vector<vector<int>> &dp) {
        if(i >= nums.size()) {
            return false;
        }
        if(target <= 0) {
            return target == 0;
        }
        if(dp[i][target] != -1) {
            return dp[i][target];
        } 
        
        return dp[i][target] = (recurse(nums, i + 1, target - nums[i], dp) || recurse(nums, i + 1, target, dp));
    }
    
    bool canPartition(vector<int>& nums) {
        
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if(sum % 2) return false;
        sum /= 2;
        dp.assign(nums.size() + 1, vector<int>(sum + 1, -1));
        return recurse(nums, 0, sum, dp);
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 68. Number of Submatrices That Sum To Target

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
        int M = matrix.size(), N = matrix[0].size(), ans = 0;
        vector<vector<int>> sum(M + 1, vector<int>(N + 1, 0));
        for (int i = 1; i <= M; ++i) {
            for (int j = 1; j <= N; ++j) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
        for (int i = 0; i < N; ++i) {
           for (int j = i + 1; j <= N; ++j) {
               unordered_map<int, int> m {{ 0, 1 }};
               for (int k = 1; k <= M; ++k) {
                   int val = sum[k][j] - sum[k][i];
                   ans += m[val - target];
                   m[val]++;
               }
           }
        }
        return ans;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)


## 69. Shortest Path in Binary Matrix

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int dirs[8][2] = { {-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
    int shortestPathBinaryMatrix(vector<vector<int>>& G) {
        if (G[0][0] == 1) return -1;
        int N = G.size();
        vector<vector<int>> dist(N, vector<int>(N, INT_MAX));
        queue<pair<int, int>> q;
        q.emplace(0, 0);
        dist[0][0] = 1;
        while (q.size()) {
            auto [x, y] = q.front();
            q.pop();
            for(int i = 0; i < 8; i++) {
                int a = x + dirs[i][0];
                int b = y + dirs[i][1];
                if (a < 0 || a >= N || b < 0 || b >= N || G[a][b] == 1 || dist[a][b] != INT_MAX) continue;
                dist[a][b] = dist[x][y] + 1;
                q.emplace(a, b);
            }
        }
        return dist[N - 1][N - 1] == INT_MAX ? -1 : dist[N - 1][N - 1];
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 70.Validate Binary Search Tree

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root, TreeNode* left = NULL, TreeNode* right = NULL) {
        if(!root) {
            return true;
        }
        
        if(left && root->val <= left->val || right && root->val >= right->val) {
            return false;
        }
        
        return (isValidBST(root->left, left, root) && isValidBST(root->right, root, right));
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 71. Reverse Nodes in k-Group

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode h, *tail = &h;
        while (head) {
            auto prev = tail;
            int i = 0;
            for (auto p = head; i < k && p; ++i, p = p->next);
            if (i < k) {
                tail->next = head;
                break;
            }
            for (int i = 0; i < k && head; ++i) {
                auto node = head;
                head = head->next;
                node->next = prev->next;
                prev->next = node;
            }
            while (tail->next) tail = tail->next;
        }
        return h.next;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 72. Trapping Rain Water

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int trap(vector<int>& A) {
        int N = A.size(), ans = 0;
        vector<int> left(N, 0), right(N, 0);
        for (int i = 1; i < N; ++i) left[i] = max(left[i - 1], A[i - 1]);
        for (int i = N - 2; i >= 0; --i) right[i] = max(right[i + 1], A[i + 1]);
        for (int i = 1; i < N - 1; ++i) ans += max(0, min(left[i], right[i]) - A[i]);
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 73. Find Missing Positive

<details>
<summary> View Code </summary>

```cpp
int firstMissingPositive(vector<int>& A) {
    int i, N = A.size();
    for (i = 0; i < N; ) {
        if (A[i] == i + 1 || A[i] < 1 || A[i] >= N + 1 || A[i] == A[A[i] - 1]) ++i;
        else swap(A[i], A[A[i] - 1]);
    }
    for (i = 0; i < N && A[i] == i + 1; ++i);
    return i + 1;
}

int firstMissingPositive(vector<int>& nums) {
    int N = nums.size();
    // Ignore negatives and zero.
    for(int i = 0; i < N; i++) if(nums[i] <= 0) nums[i] = N + 1;
    
    // Replacing numbers with their negatives
    for(int i = 0; i < N; i++) {
        if(abs(nums[i]) <= N && nums[abs(nums[i]) - 1] > 0) {
            nums[abs(nums[i]) - 1] *= -1;
        }
    }
    
    for(int i = 0; i < N; i++) {
        if(nums[i] > 0) {
            return i + 1;
        }
    }
    
    return N + 1;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 74. Edit Distance

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int M = word1.size();
        int N = word2.size();
        if(!M) return N;
        if(!N) return M;
        
        vector<vector<int>> dp(M + 1, vector<int>(N + 1, INT_MAX));
        
        dp[0][0] = 0;
        
        for(int i = 0; i < M; i++) {
            dp[i + 1][0] = i + 1;
        }
        
        for(int j = 0; j < N; j++) {
            dp[0][j + 1] = j + 1;
        }
        
        for(int i = 0; i < M; i++) {
            for(int j = 0; j < N; j++) {
                if(word1[i] == word2[j]) {
                    dp[i + 1][j + 1] = dp[i][j];
                } else {
                    dp[i + 1][j + 1] = 1 + min({dp[i][j], dp[i + 1][j], dp[i][j + 1]});
                }
            }
        }
        
        return dp[M][N];
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 75. Climbing Stairs

<details>
<summary> View Code </summary>

```cpp
int climbStairs(int n) {
    int prev = 0, cur = 1;
    while (n--) {
        int next = cur + prev;
        prev = cur;
        cur = next;
    }
    return cur;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 76. Shifting Letters II

<details>
<summary> View Code </summary>

```cpp
// Solution 1 - Line Sweep
string shiftingLetters(string s, vector<vector<int>>& shifts) {
    int line[50001] = {};
    for (auto &shift : shifts) {
        line[shift[0]] += shift[2] ? 1 : -1;
        line[shift[1] + 1] += shift[2] ? -1 : 1;
    }
    for (int i = 0, val = 0; i < s.size(); ++i) {
        val = (val + line[i]) % 26;
        s[i] = 'a' + (26 + (s[i] - 'a') + val) % 26;
    }
    return s;
}

// Solution 2 - Fenwick Tree
constexpr int static n = 50000;
int bt[n + 1] = {};
int prefix_sum(int i)
{
    int sum = 0;
    for (i = i + 1; i > 0; i -= i & (-i))
        sum += bt[i];
    return sum;
}
void add(int i, int val)
{
    for (i = i + 1; i <= n; i += i & (-i))
        bt[i] += val;
}
string shiftingLetters(string s, vector<vector<int>>& shifts) {
    for (auto &shift : shifts) {
        add(shift[0], shift[2] == 1 ? 1 : -1);
        add(shift[1] + 1, shift[2] == 1 ? -1 : 1);
    }
    for (int i = 0; i < s.size(); ++i)
        s[i] = 'a' + (26 + (s[i] - 'a') + prefix_sum(i) % 26) % 26;
    return s;
}

// Solution 3 - Segment Tree
class Solution {
public:
    vector<int> seg;

    void upd(int l, int r, int v, int x, int lx, int rx) {
        if(lx > r or rx < l) return;
        if(lx >= l and rx <= r) {
            seg[x] += v;
            return;
        }
        int mid = (lx + rx) / 2;
        upd(l, r, v, 2 * x + 1, lx, mid);
        upd(l, r, v, 2 * x + 2, mid + 1, rx);
    }

    int query(int i, int x, int lx, int rx) {
        if(lx == rx) return seg[x];

        int mid = (lx + rx) / 2;

        if(i <= mid)
            return seg[x] + query(i, 2 * x + 1, lx, mid);

        return seg[x] + query(i, 2 * x + 2, mid + 1, rx);
    }
    
    string shiftingLetters(string s, vector<vector<int>>& shifts) {
        long x = 1;
        while(x <= s.length()) x <<= 1;
        seg.resize(2 * x, 0);
        
        for(int i = 0; i < shifts.size(); ++i) {
            int l = shifts[i][0], r = shifts[i][1], dir;
            if(shifts[i][2] == 0) dir = -1;
            else dir = 1;
            upd(l, r, dir, 0, 0, x - 1);
        }
        
        for(int i = 0; i < s.length(); ++i) {
            int shift = query(i, 0, 0, x - 1);
            int dir = (shift > 0) ? 1 : -1;
            shift = abs(shift) % 26; 
            
            shift *= dir;
            int cur = s[i] - 'a';
            cur = (cur + shift + 26) % 26;
            s[i] = char(cur + 'a');
        }
        return s;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 77. Build A Matrix With Conditions

<details>
<summary> View Code </summary>

```cpp
vector<vector<int>> buildMatrix(int k, vector<vector<int>>& rowConditions, vector<vector<int>>& colConditions) {
	vector<int> order1 = topologicalSort(rowConditions, k);
	vector<int> order2 = topologicalSort(colConditions, k);
	if (order1.size() < k || order2.size() < k) return {};
	unordered_map<int, int> m;
	for (int i = 0; i < k; i++) m[order2[i]] = i;
	vector<vector<int>> ans(k, vector<int>(k, 0));
	for (int i = 0; i < k; i++)
		ans[i][m[order1[i]]] = order1[i];
	return ans;
}
vector<int> topologicalSort(vector<vector<int>> &A, int k) {
	vector<int> deg(k, 0), order;
	vector<vector<int>> graph(k, vector<int>(0));
	queue<int> q;
	for (auto &c: A) {
		graph[c[0] - 1].push_back(c[1] - 1);
		deg[c[1] - 1]++;
	}
	for(int i = 0; i < k; i++) 
		if (!deg[i]) q.push(i);
	while (!q.empty()) {
		int x = q.front(); q.pop();
		order.push_back(x + 1);
		for (int& y: graph[x]) 
			if (--deg[y] == 0) 
				q.push(y);
	}
	return order;
}
```

</details>

<br>[⬆ Back to top](#table-of-contents)


## 78. Serialize and Deserialize Binary Tree

<details>
<summary> View Code </summary>

```cpp
class Codec {
private:
    TreeNode *getNode(vector<string> &v, int &i) {
        string s = v[i++];
        return s == "#" ? NULL : new TreeNode(stoi(s));
    }
public:
    string serialize(TreeNode* root) {
        if (!root) return "";
        queue<TreeNode*> q;
        q.push(root);
        string ans;
        while (!q.empty()) {
            root = q.front();
            q.pop();
            if (!ans.empty()) ans += ',';
            if (root) {
                ans += to_string(root->val);
                q.push(root->left);
                q.push(root->right);
            } else ans += '#';
        }
        return ans;
    }
    TreeNode* deserialize(string data) {
        if (data.empty()) return NULL;
        stringstream ss(data);
        string val;
        vector<string> v;
        while (getline(ss, val, ',')) v.push_back(val);
        TreeNode *root = new TreeNode(stoi(v[0]));
        queue<TreeNode*> q;
        q.push(root);
        int i = 1;
        while (i < v.size()) {
            TreeNode *node = q.front();
            q.pop();
            node->left = getNode(v, i);
            node->right = getNode(v, i);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        return root;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 79. Pacific Atlantic Water Flow

<details>
<summary> View Code </summary>

```cpp
class Solution {
    int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}}, M, N;
    void dfs(vector<vector<int>> &A, int x, int y, vector<vector<int>> &m) {
        if (m[x][y]) return;
        m[x][y] = 1;
        for (auto &[dx, dy] : dirs) {
            int a = x + dx, b = y + dy;
            if (a < 0 || a >= M || b < 0 || b >= N || A[a][b] < A[x][y]) continue;
            dfs(A, a, b, m);
        }
    }
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& A) {
        if (A.empty() || A[0].empty()) return {};
        M = A.size(), N = A[0].size();
        vector<vector<int>> a(M, vector<int>(N)), b(M, vector<int>(N)), ans; 
        for (int i = 0; i < M; ++i) {
            dfs(A, i, 0, a);
            dfs(A, i, N - 1, b);
        }
        for (int j = 0; j < N; ++j) {
            dfs(A, 0, j, a);
            dfs(A, M - 1, j, b);
        }
        for (int i = 0; i < M; ++i) {
            for (int j = 0; j < N; ++j) {
                if (a[i][j] && b[i][j]) ans.push_back({i, j});
            }
        }
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 80. Delete and Earn

<details>
<summary> View Code </summary>

```cpp
int deleteAndEarn(vector<int>& nums) {
    vector<int> dp(10002, 0);
    vector<int> sum(10002, 0);
    
    for(auto a : nums) {
        sum[a] += a;
    }
    
    dp[0] = sum[0];
    dp[1] = sum[1];
    
    for(int i = 2; i < 10001; i++) {
        dp[i] = max(dp[i - 1], dp[i - 2] + sum[i]);
    }
    
    return dp[10000];
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 81. Permutations II

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<vector<int>> ans;
    void permute(vector<int> nums, int start) {
        if(start == nums.size() - 1) {
            ans.push_back(nums);
            return;
        }
        
        for(int i = start; i < nums.size(); i++) {
            if(i != start && nums[i] == nums[start]) continue;
            swap(nums[i], nums[start]);
            permute(nums, start + 1);
        }
    }
    
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        permute(nums, 0);
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 82. Combination Sum II

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& A, int target) {
        
        int N = A.size();
        sort(A.begin(), A.end());
        vector<vector<int>> ans;
        vector<int> temp;
        
        function<void(int, int)> dfs = [&](int start, int goal) {
            if(goal == 0) {
                ans.push_back(temp);
                return;
            }
            
            for(int i = start; i < N && goal - A[i] >= 0 ; i++) {
                if(i != start && A[i] == A[i - 1]) continue;
                temp.push_back(A[i]);
                dfs(i + 1, goal - A[i]);
                temp.pop_back();
            }
        };
        
        dfs(0, target);
        
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 83. Non Overlapping Intervals

<details>
<summary> View Code </summary>

```cpp
int eraseOverlapIntervals(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end(), [](auto &a, auto &b) {
        return a[1] < b[1];
    });
    
    int overlapCnt = 0;
    int end = INT_MIN;
    
    for(auto &e : intervals) {
        if(e[0] >= end) {
            end = e[1];
        } else {
            overlapCnt++;
        }
    }
    
    return overlapCnt;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 84. Best Time To Buy and Sell Stocks With Cooldown

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int maxProfit(vector<int>& A) {
        if (A.empty()) return 0;
        int N = A.size(), buy = INT_MIN;
        vector<int> dp(N + 1, 0);
        for (int i = 0; i < N; ++i) {
            buy = max(buy, (i >= 1 ? dp[i - 1] : 0) - A[i]);
            dp[i + 1] = max(dp[i], buy + A[i]);
        }
        return dp[N];
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 85. Maximum XOR of Two Numbers In An Array

<details>
<summary> Approach </summary>

This algorithm's idea is:
to iteratively determine what would be each bit of the final result from left to right. And it narrows down the candidate group iteration by iteration. e.g. assume input are `a,b,c,d,...z`, `26` integers in total. In first iteration, if you found that `a, d, e, h, u` differs on the MSB(most significant bit), so you are sure your final result's MSB is set. Now in second iteration, you try to see if among `a, d, e, h, u` there are at least two numbers make the 2nd MSB differs, if yes, then definitely, the 2nd MSB will be set in the final result. And maybe at this point the candidate group shinks from `a,d,e,h,u` to `a, e, h`. Implicitly, every iteration, you are narrowing down the candidate group, but you don't need to track how the group is shrinking, you only cares about the final result.

* The mask will grow like  `100..000 , 110..000, 111..000,  then 1111...111` for each iteration, we only care about the left parts.
* We only care about the left parts, for example, if `i = 2`, then we have `{1100, 1000, 0100, 0000}` from `{1110, 1011, 0111, 0010}`.
* If `i = 1`and before this iteration, the maxResult we have now is `1100`, my wish is the maxResult will grow to `1110`, so I will try to find a candidate which can give me the greedyTry.
* This is the most tricky part, coming from a fact that if `a ^ b = c`, then `a ^ c = b`, now we have the `c`, which is greedyTry, and we have the `a`, which is leftPartOfNum. If we hope the formula `a ^ b = c` to be valid, then we need the `b`,  and to get `b`, we need `a ^ c`, if `a ^ c` exisited in our set, then we're good to go.
</details>

<details>
<summary> Solution - Bitmasks </summary>

```cpp
class Solution {
public:
    int findMaximumXOR(vector<int>& A) {
        unordered_set<int> s;
        int mask = 0, ans = 0;
        for (int i = 31; i >= 0; --i) {
            mask |= 1 << i;
            s.clear();
            for (int n : A) s.insert(n & mask);
            int next = ans | (1 << i);
            for (int prefix : s) {
                if (!s.count(next ^ prefix)) continue;
                ans |= 1 << i;
                break;
            }
        }
        return ans;
    }
};

```
</details>

<details>
<summary> Solution - Trie </summary>

```cpp
struct TrieNode {
    TrieNode *next[2] = {};
};
class Solution {
    void add(TrieNode *node, int n) {
        for (int i = 31; i >= 0; --i) {
            int b = n >> i & 1;
            if (node->next[b] == NULL) node->next[b] = new TrieNode();
            node = node->next[b];
        }
    }
    int maxXor(TrieNode *node, int n) {
        int ans = 0;
        for (int i = 31; i >= 0; --i) {
            int b = n >> i & 1;
            if (node->next[1 - b]) { // if we can go the opposite direction, do it.
                node = node->next[1 - b];
                ans |= 1 << i;
            } else {
                node = node->next[b];
            }
        }
        return ans;
    }
public:
    int findMaximumXOR(vector<int>& A) {
        TrieNode root;
        int ans = 0;
        for (int n : A) {
            add(&root, n);
            ans = max(ans, maxXor(&root, n));
        }
        return ans;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 86. Implement Queue Using Stacks

<details>
<summary> View Code </summary>

```cpp
class MyQueue {
public:
    
    stack<int> S1, S2;
    
    void push(int x) {
        while(!S1.empty()) {
            S2.push(S1.top());
            S1.pop();
        }
        
        S2.push(x);
        
        while(!S2.empty()) {
            S1.push(S2.top());
            S2.pop();
        }
    }
    
    int pop() {
        int x = S1.top();
        S1.pop();
        
        return x;
    }
    
    int peek() {
        return S1.top();
    }
    
    bool empty() {
        return S1.empty();
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 87. Minimum Size Subarray Sum 

<details>
<summary> View Code </summary>

```cpp
int minSubArrayLen(int target, vector<int>& nums) {   
    int N = nums.size();
    int i = 0, sum = 0, ans = INT_MAX;
    
    for(int j = 0; j < N; j++) {
        sum += nums[j];
        
        while(sum >= target) {
            if(sum >= target) {
                ans = min(ans, j - i + 1);
            }
            sum -= nums[i++];
        }  
    }
    
    return ans == INT_MAX ? 0 : ans;
}
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 88. Number of Visible People In A Queue

<details>
<summary> View Code </summary>

```cpp
vector<int> canSeePersonsCount(vector<int>& A) {
    stack<int> S;
    int N = A.size();
    vector<int> ans(N, 0);
    
    for(int i = 0; i < N; i++) {
        // Monotonically Increasing Sequence
        while(S.size() && A[S.top()] <= A[i]) {
            ans[S.top()]++;
            S.pop();
        }
        
        if(S.size()) {
            ans[S.top()]++;
        }
        
        S.push(i);
    }    
    return ans;    
}
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 89. Describe The Painting 

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<vector<long long>> splitPainting(vector<vector<int>>& segments) {
        long long line[200001] = {};
        bool change[200001] = {};
        
        int maxEnd = -1;
        
        for(auto &e : segments) {
            int start = e[0], end = e[1], value = e[2];
            line[start] += value;
            line[end] -= value;
            change[start] = change[end] = true;
            maxEnd = max(maxEnd, end);
        }
        
        for(int i = 1; i <= maxEnd; i++) {
            line[i] += line[i - 1];
        }
        
        vector<vector<long long>> ans;
        
        for(int i = 0; i <= maxEnd;) {
            int start = i;
            while(i <= maxEnd && line[i] == line[start] && (i == start || !change[i])) i++;
            
            if(line[start]) {
                ans.push_back({start, i, line[start]});
            }
        }
        
        return ans;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 90. Flood Fill

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    
    int dirs[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
    int M, N, startingColor;
    
    void dfs(vector<vector<int>> &image, int x, int y, int C) {
        
        image[x][y] = C;
        
        for(auto &dir : dirs) {
            int a = x + dir[0];
            int b = y + dir[1];
            
            if(a < 0 || b < 0 || a >= M || b >= N || image[a][b] != startingColor) continue;
            
            dfs(image, a, b, C);
        }
    }
    
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        M = image.size();
        N = image[0].size();
        
        startingColor = image[sr][sc];
        
        if(color == startingColor) {
            return image;
        }
        
        dfs(image,  sr, sc, color);
        
        return image;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 91. Palindrome Partitioning

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    
    bool isPalindrome(string &s, int i, int j) {
        while(i < j && s[i] == s[j]) {
            i++;
            j--;
        }
        return i >= j;
    }
    
    vector<vector<string>> ans;
    vector<string> temp;
    
    void dfs(string &s, int start) {
        if(start == s.size()) {
            ans.push_back(temp);
            return;
        }
        
        for(int i = start; i < s.length(); i++) {
            if(!isPalindrome(s, start, i)) continue;
            
            temp.push_back(s.substr(start, i - start + 1));
            dfs(s, i + 1);
            temp.pop_back();
        }
    }
    
    vector<vector<string>> partition(string s) {
        dfs(s, 0);
        return ans;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 92. Path With Maximum Gold

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int M, N;
    int dirs[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
    int maxGold = 0;
    
    
    void dfs(vector<vector<int>>& grid, int x, int y, int cnt) {
        
        // Store gold in current cell.
        int gold = grid[x][y];
        grid[x][y] = 0;
        
        cnt += gold;
        maxGold = max(maxGold, cnt);
        
        for(auto &dir : dirs) {
            int a = x + dir[0];
            int b = y + dir[1];
            
            if(a < 0 || b < 0 || a >= M || b >= N || grid[a][b] == 0) continue;
            
            dfs(grid, a, b, cnt);
        }
        
        grid[x][y] = gold;
    }
    
    int getMaximumGold(vector<vector<int>>& grid) {
        M = grid.size();
        N = grid[0].size();
        
        for(int i = 0; i < M; i++) {
            for(int j = 0; j < N; j++) {
                if(grid[i][j] == 0) continue;
                dfs(grid, i, j, 0);
            }
        }
        
        return maxGold;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 93. Counting Bits

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    vector<int> countBits(int N) {
        vector<int> dp(N + 1);
        
        dp[0] = 0;
        
        for(int i = 1; i <= N; i++) {
            dp[i] = dp[i / 2] + (i & 1);
        }
        
        return dp;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 94. Word Break

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        
        unordered_set<string> M(wordDict.begin(), wordDict.end());
        
        int N = s.size();
        vector<bool> dp(N + 1);
        dp[0] = true;
        
        for(int i = 1; i <= N; i++) {
            for(int j = 0; j < i && !dp[i]; j++) {
                dp[i] = dp[j] && M.count(s.substr(j, i - j));
            }
        }
        
        return dp[N];
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 95. Find Median From Data Stream

<details>
<summary> View Code </summary>

```cpp
class MedianFinder {
public:
    priority_queue<int, vector<int>, greater<int>> maxHeap;
    priority_queue<int, vector<int>> minHeap;
    
    void addNum(int num) {
        if(minHeap.empty()) {
            minHeap.push(num);
        } else if(num < minHeap.top()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
            minHeap.push(num);
        } else {
            maxHeap.push(num);
        }
        
        while(maxHeap.size() > minHeap.size()) {
            minHeap.push(maxHeap.top());
            maxHeap.pop();
        }
    }
    
    double findMedian() {
        if(maxHeap.size() == minHeap.size()) {
            return (double)(maxHeap.top() + minHeap.top()) / 2;
        } else {
            return (double)(minHeap.top());
        }
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 96. Single Threaded CPU

<details>
<summary> View Code </summary>

```cpp
class Solution {
    typedef pair<int, int> T;
public:
    vector<int> getOrder(vector<vector<int>>& A) {
        priority_queue<T, vector<T>, greater<>> pq;
        long N = A.size(), time = 0, i = 0;
        for (int i = 0; i < N; ++i) A[i].push_back(i);
        sort(begin(A), end(A));
        vector<int> ans;
        while (i < N || pq.size()) { 
            if (pq.empty()) {
                time = max(time, (long)A[i][0]);
            }
            while (i < N && time >= A[i][0]) {
                pq.emplace(A[i][1], A[i][2]);
                ++i;
            }
            auto [pro, index] = pq.top();
            pq.pop();
            time += pro;
            ans.push_back(index);
        }
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 97. Contiguous Array

<details>
<summary> View Code </summary>

```cpp
int findMaxLength(vector<int>& A) {
    unordered_map<int, int> m{{0,-1}};
    int ans = 0;
    for (int i = 0, sum = 0; i < A.size(); ++i) {
        sum += A[i] ? 1 : -1;
        if (m.count(sum)) ans = max(ans, i - m[sum]);
        else m[sum] = i;
    }
    return ans;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 98. Falling Squares
<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
  int n;
  vector<int> height, lazy;

  void push_up(int i) {
    height[i] = max(height[i*2], height[i*2+1]);
  }

  void push_down(int i) {
    if (lazy[i]) {
        lazy[i*2] = lazy[i*2+1] = lazy[i];
        height[i*2] = height[i*2+1] = lazy[i];
        lazy[i] = 0;
    }
  }

  void update(int i, int l, int r, int L, int R, int val) {
    if (L <= l && r <= R) {
      height[i] = val;
      lazy[i] = val;
      return;
    }
    push_down(i);
    int mid = l + (r-l)/2;
    if (L < mid) update(i*2, l, mid, L, R, val);
    if (R > mid) update(i*2+1, mid, r, L, R, val);
    push_up(i);
  }

  int query(int i, int l, int r, int L, int R) {
    if (L <= l && r <= R) return height[i];
    push_down(i);
    int res = 0;;
    int mid = l + (r-l)/2;
    if (L < mid) res = max(res, query(i*2, l, mid, L, R));
    if (R > mid) res = max(res, query(i*2+1, mid, r, L, R));
    return res;
  }

  vector<int> fallingSquares(vector<pair<int, int>>& positions) {
    vector<int> a;
    for (auto& p : positions) {
      a.push_back(p.first);
      a.push_back(p.first+p.second);
    }
    sort(a.begin(), a.end());
    n = unique(a.begin(), a.end()) - a.begin();
    a.resize(n);
    
    height.resize(n<<2, 0);
    lazy.resize(n<<2, 0);
    vector<int> res;
    for (auto& p : positions) {
      int l = lower_bound(a.begin(), a.end(), p.first) - a.begin();
      int r = lower_bound(a.begin(), a.end(), p.first+p.second) - a.begin();
      int maxh = query(1, 0, n, l, r);
      update(1, 0, n, l, r, maxh+p.second);
      res.push_back(query(1, 0, n, 0, n));
    }
    return res;
  }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 99. Minimum XOR Sum of Two Arrays

<details>
<summary> View Code </summary>

```cpp
class Solution {
    int dp[15][17000];
    int recursion(vector<int> &nums1, vector<int>&nums2, int i, int mask) {
        
        if(i >= nums1.size()) return 0;
        if(dp[i][mask] != -1) return dp[i][mask];
        
        int ans = INT_MAX;

        for(int j = 0; j < nums2.size(); j++) {
            if(mask & (1 << j)) continue;
            int val = nums1[i] ^ nums2[j];

            ans = min(ans, recursion(nums1, nums2, i + 1, mask | (1 << j)) + val);
        }

        return dp[i][mask] = ans;
    }

public:
    int minimumXORSum(vector<int>& nums1, vector<int>& nums2) {
        memset(dp, -1, sizeof(dp));
        return recursion(nums1, nums2, 0, 0);
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 100. Maximum Profit In Job Scheduling

<details>
<summary> View Code </summary>

```cpp
class Solution {
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        vector<array<int, 3>> jobs;
        for (int i = 0; i < startTime.size(); ++i) jobs.push_back({ startTime[i], endTime[i], profit[i] });
        sort(begin(jobs), end(jobs), greater<>());
        map<int, int> dp{{INT_MAX, 0}};
        int ans = 0;
        for (auto &[s, e, p] : jobs) {
            dp[s] = max(ans, p + dp.lower_bound(e)->second);
            ans = max(ans, dp[s]);
        }
        return ans;
    }
};

```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 101. Find Minimum Time To Finish All Jobs

<details>
<summary> View Code </summary>

```cpp
int dp[13][1 << 12], sum[1 << 12];
class Solution {
public:
    int minimumTimeRequired(vector<int>& A, int k) {
        int N = A.size();
        memset(dp, 0x3f, sizeof(dp));
        memset(sum, 0, sizeof(sum));
        for (int i = 0; i <= k; ++i) dp[i][0] = 0;
        for (int mask = 0; mask < (1 << N); ++mask) {
            for (int i = 0; i < N; ++i) {
                if (mask & (1 << i)) sum[mask] += A[i];
            }
        }
        for (int i = 0; i < k; ++i) {
            for (int mask = 0; mask < (1 << N); ++mask) {
                for (int sub = mask; sub; sub = (sub - 1) & mask) {
                    dp[i + 1][mask] = min(dp[i + 1][mask], max(dp[i][mask ^ sub], sum[sub]));
                }
            }
        }
        return dp[k][(1 << N) - 1];
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 102. Course Schedule

<details>
<summary> View Code </summary>

```cpp
bool canFinish(int n, vector<vector<int>>& E) {
    vector<vector<int>> G(n);
    vector<int> indegree(n);
    for (auto &e : E) {
        G[e[1]].push_back(e[0]);
        ++indegree[e[0]];
    }
    queue<int> q;
    for (int i = 0; i < n; ++i) {
        if (indegree[i] == 0) q.push(i);
    }
    while (q.size()) {
        int u = q.front();
        q.pop();
        --n;
        for (int v : G[u]) {
            if (--indegree[v] == 0) q.push(v);
        }
    }
    return n == 0;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 103. Minimum Height Trees

<details>
<summary> View Code </summary>

```cpp
vector<int> findMinHeightTrees(int n, vector<vector<int>>& E) {
    if (n == 1) return { 0 };
    vector<int> degree(n), ans;
    vector<vector<int>> G(n);
    for (auto &e : E) {
        int u = e[0], v = e[1];
        degree[u]++;
        degree[v]++;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    queue<int> q;
    for (int i = 0; i < n; ++i) {
        if (degree[i] == 1) q.push(i);
    }
    while (n > 2) {
        int cnt = q.size();
        n -= cnt;
        while (cnt--) {
            int u = q.front();
            q.pop();
            for (int v : G[u]) {
                if (--degree[v] == 1) q.push(v);
            }
        }
    }
    while (q.size()) {
        ans.push_back(q.front());
        q.pop();
    }
    return ans;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 104. Russian Doll Envelopes

<details>
<summary> View Code </summary>

```cpp
int maxEnvelopes(vector<vector<int>>& A) {
    sort(begin(A), end(A), [](auto &a, auto &b) { return a[0] != b[0] ? a[0] < b[0] : a[1] > b[1]; });
    vector<int> dp;
    for (auto &v : A) {
        auto it = lower_bound(begin(dp), end(dp), v[1]);
        if (it == end(dp)) dp.push_back(v[1]);
        else *it = v[1];
    }
    return dp.size();
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 105. Maximum AND Sum of Array

<details>
<summary> View Code </summary>

```cpp
int maximumANDSum(vector<int>& A, int numSlots) {
    A.resize(2 * numSlots); // append 0s to make sure the length of `A` is `2 * numSlots`
    int N = A.size();
    vector<int> dp(1 << N);
    for (int m = 1; m < 1 << N; ++m) {
        int cnt = __builtin_popcount(m), slot = (cnt + 1) / 2; 
        for (int i = 0; i < N; ++i) {
            if (m >> i & 1) { // we assign A[i] to `slot`-th slot
                dp[m] = max(dp[m], dp[m ^ (1 << i)] + (slot & A[i]));
            }
        }
    }
    return dp[(1 << N) - 1];
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 106. Maximum Number of Robots Within Budget

<details>
<summary> View Code - Sliding Window </summary>

```cpp
int maximumRobots(vector<int>& times, vector<int>& costs, long long budget) {  
    long long N = times.size(), ans = 0, i = 0, sum = 0;
    multiset<int> S;
    
    for(int j = 0; j < N; j++) {
        
        sum += costs[j];
        S.insert(times[j]);
        
        // *S.rbegin() will return the largest element present in multiset.
        
        if(*S.rbegin() + (sum * (j - i + 1)) > budget) {
            sum -= costs[i];
            S.erase(S.find(times[i++]));
        }
    }
    
    return N - i;
}
```

`Why does returning N - i works ?`   
That's really the ingenious part of this implementation. The key is in the `if` statement. We are not using `while` loop which is what people typically do. By using `if`, it is guaranteed that the distance between i and j will not decrease once it reaches certain value. As a result, `N - i` will be the largest value one has seen in the loop.

</details>

<details>
<summary> View Code - Sparse Table and Binary Search </summary>

```cpp
#define ll long long
struct sparse_table {
    ll level, n;
    vector<vector<ll>> table;
    vector<ll> lg;
    
    sparse_table(vector<int> &a) {
        n = a.size();
        level = ceil(log2(n));
        table.resize(n, vector<ll> (level + 1));
        lg.resize(n + 1);
        build(a);
    }
    
    void build(vector<int> &a) {
        lg[1] = 0;
        for(int i = 2; i < n + 1; ++i)
            lg[i] = lg[i / 2] + 1;
            
        for(int i = 0; i < n; ++i) 
            table[i][0] = a[i];
        
        for(int j = 1; j <= level; ++j) {
            for(int i = 0; i + (1LL << j) <= n; ++i) {
                table[i][j] = max(table[i][j - 1], table[i + (1LL << (j - 1))][j - 1]);
            }
        }
    }
    
    ll query(ll l, ll r) {
        l--, r--;
        ll j = lg[r - l + 1];
    
        return max(table[l][j], table[r - (1LL << j) + 1][j]);
    }
};
class Solution {
public:
    int maximumRobots(vector<int>& ct, vector<int>& rt, long long budget) {
        ll n = ct.size();
        sparse_table rmq(ct); // for getting maximum in a range [l, r] in O(1)
        
        vector<ll> pre(n + 1, 0);
        for(int i = 0; i < n; ++i) pre[i + 1] =  pre[i] + rt[i]; // precalculating prefix sums on running costs
        
        ll res = 0;
        for(int i = 0; i < n; ++i) {
            int lo = i, hi = n - 1, ind = -1;
            while(lo <= hi) {
                int mid = lo + (hi - lo) / 2;
                ll mx = rmq.query(i + 1, mid + 1); // maximum in the current range
                ll sum = pre[mid + 1] - pre[i]; // range sum 
                
                if(mx + (mid - i + 1) * sum <= budget) { // if the current range cost is less than or equal to budget
                    ind = mid;
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
            if(ind != -1) {
                res = max(res, 1LL * (ind - i + 1));
            }
        }
        return res;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 107. Find Longest Awesome Substring

<details>
<summary> Approach </summary>
Encode the parity of each digit using bit mask. For example, if we've seen `001233444`, we encode it as `10110` because there are odd numbers of `1, 2, 4` and even numbers of `0, 3`.

We use a map `m` to store the mapping from the bitmask to the index of the first occurrence of that bitmask.

For the current `mask`, we have two options:
* all the digits in the window appeared even number times. The maximum length of such window is `i - m[mask]`.
* Only a single digit in the window appeared odd number times. Assume it's digit `0 <= j < 9`, the maximum length of such window is `i - m[mask ^ (1 << j)]`

For example - consider this number - `3242415`

* Mask at i = 0 is `00001000`
* Mask at i = 1 is `00001100`
* Mask at i = 2 is `00011100`
* Mask at i = 3 is `00011000`
* Mask at i = 4 is `00001000`
* Mask at i = 5 is `00001010`
* Mask at i = 6 is `00101010`

In this case, if you see the mask at index `i = 0` and `i = 4` are same, hence we will store it in answer as `4 - 0 + 1`  as `5`.

For checking single digits if it is appeared odd number of times.

In our case, mask at `i = 0` is `0000001000`
We will try to check if any of the digits is odd from 0 to 9, by doing  `mask ^ (1 << j)`

Mask at `j = 0` is `0000001001`
Mask at `j = 1` is `0000001010`
Mask at `j = 2` is `0000001100`
Mask at `j = 3` is `0000000000`
Mask at `j = 4` is `0000011000`
Mask at `j = 5` is `0000101000`
Mask at `j = 6` is `0001001000`
Mask at `j = 7` is `0010001000`
Mask at `j = 8` is `0100001000`
Mask at `j = 9` is `1000001000`

</details>

<details>
<summary> Solution - Bitmasks and Prefix State Map </summary>

```cpp
class Solution {
public:
    int longestAwesome(string s) {
        unordered_map<int, int> m{{0,-1}}; // mask -> index of first occurrence
        int ans = 0;
        for (int i = 0, mask = 0; i < s.size(); ++i) {
            mask ^= 1 << (s[i] - '0');
            if (m.count(mask)) ans = max(ans, i - m[mask]);
            else m[mask] = i;
            for (int j = 0; j < 10; ++j) {
                int prev = mask ^ (1 << j);
                if (m.count(prev)) ans = max(ans, i - m[prev]);
            }
        }
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)


## 108. Maximum Rows Covered By Columns

<details>
<summary> Solution - Bitmasks </summary>

```cpp
int maximumRows(vector<vector<int>>& a, int cols) {
        int n = (int) a.size();
        int m = (int) a[0].size();
        int ans = -1;
        for (int mask = 0; mask < (1 << m); mask++) {
            if (__builtin_popcount(mask) != cols) {
                continue;
            }
            int t = (1 << n) - 1;
            for (int i = 0; i < m; i++) {
                if (~mask & (1 << i)) {
                    for (int j = 0; j < n; j++) {
                        if (a[j][i]) {
                            t &= ~(1 << j);
                        }
                    }
                }
            }
            ans = max(ans, __builtin_popcount(t));
        }
        return ans;
    }
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 109. Create Sorted Array Through Instructions

<details>
<summary> Solution - Binary Indexed Tree (Fenwick Tree) </summary>

```cpp
int c[100001];
int createSortedArray(vector<int>& A) {
    memset(c, 0, sizeof(c));
    int res = 0, n = A.size(), mod = 1e9 + 7;
    for (int i = 0; i < n; ++i) {
        res = (res + min(get(A[i] - 1), i - get(A[i]))) % mod;
        update(A[i]);
    }
    return res;
}

void update(int x) {
    while (x < 100001) {
        c[x]++;
        x += x & -x;
    }
}

int get(int x) {
    int res = 0;
    while (x > 0) {
        res += c[x];
        x -= x & -x;
    }
    return res;
}
```
</details>

<details>
<summary> Solution - Segment Tree </summary>

```cpp
//  Segment Tree Array
int tree[400040];

int get_mid(int a, int b) {
    return a + (b - a)/2;
}

// Fn to get sum between range s to e
int query(int index, int s, int e, int qs, int qe) {
    // 1. Base Case - Complete Overlapp
    if(s >= qs and e <= qe)
        return tree[index];
    
    // 2. Base Case - No overlapp
    if(e < qs or s > qe)
        return 0;
    
    // 3. Partial Overlapp
    int mid = get_mid(s, e);
    
    int leftAns = query(2*index + 1, s, mid, qs, qe);
    int rightAns = query(2*index + 2, mid + 1, e, qs, qe);
    
    return leftAns + rightAns;
}

void update(int index, int s, int e, int pos) {
    
    // 1. Base Case - Reached the node where update is required
    if(s == e) {
        tree[index]++;
        return;
    } 
    
    // 2. Intermidiate Node
    int mid = get_mid(s, e);
        
    if(pos <= mid) 
        update(2*index + 1, s, mid, pos);
    else
        update(2*index + 2, mid + 1, e, pos);

    tree[index] = tree[2*index + 1] + tree[2*index + 2];
}

int createSortedArray(vector<int>& instructions) {
    
    int cost = 0;
    const int MAXN = 1e5 + 1;
    const int MOD = 1e9 + 7;
    
    for(auto x : instructions) {
        // Get number of elements that are less than current element
        int less_count = query(0, 0, MAXN, 0, x - 1); 
        
        // Get number of elements which are greater than current element
        int greater_count = query(0, 0, MAXN, x + 1, MAXN); 
        
        update(0, 0, MAXN, x);
        
        cost = (cost + min(less_count, greater_count))%MOD;
    }
    
    return cost; 
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 110. Maximum Students Taking Exam

<details>
<summary> Approach </summary>

We can do the dp row by row, we start from row 1 until row n. 
`dp[i][mask]` represents that, we are now at row i and the state of this row is mask.
Now, state conversion is: We consider every possible state of the last row, and check if the state conversion is legal (that is, there will be no cheating). Hence we have:

`dp[i][mask] = max(dp[i][mask], dp[i-1][premask] + __builtin_popcount(mask));`
where mask and premask are both legal, and these two rows together will have no cheating.

</details>

<details>
<summary> Solution - Bitmasks </summary>

```cpp
class Solution {
public:
    int n,m;
    int ans = 0;
    int dp[9][(1<<8)+2];  //dp[i][mask]: we are in row i(i is from [1,9]), state is mask
    int avail[9];  //avail[i] is the mask representing available seats in row i
        
    int maxStudents(vector<vector<char>>& seats) {
        n = seats.size(); m = seats[0].size();
        memset(dp, -1, sizeof(dp));
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < m; j++) {
                if (seats[i-1][j] == '.') {
                    avail[i] |= (1<<j);
                }
            }
        }
        
        for (int mask = 0; mask < (1<<m); mask++) {
            dp[0][mask] = 0;  //initialize all illegal states with 0
        }
        
        for (int i = 1; i <= n; i++) {  //now we are at row i
            for (int premask = 0; premask < (1<<m); premask++) {
                if (dp[i-1][premask] == -1) continue;
                for (int mask = 0; mask < (1<<m); mask++) {
                    if ((mask & avail[i]) != mask) continue;
                    if (mask&(mask>>1)) continue;  //if there is adjacent 1
                    
                    /*checking this row and last row*/
                    if (mask&(premask<<1) || mask&(premask>>1)) continue;
                    dp[i][mask] = max(dp[i][mask], dp[i-1][premask] + __builtin_popcount(mask));
                }
            }
        }
        
        for (int mask = 0; mask < (1<<m); mask++) {
            ans = max(ans, dp[n][mask]);
        }
        return ans;
    }
};
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 111. Number of Ways To Reach A Position After Exactly K Steps

<details>
<summary> Solution - Recursion + DP </summary>

```cpp
class Solution {
public:
    vector<vector<long long>> dp;
    const int MOD = 1e9 + 7;

    int recur(int s, int e, int step, int current, int k) {

        if(dp[step][current + 2000] != -1e9) {
            return (dp[step][current + 2000] % MOD);
        }

        if(step == k) {
            if(current == e) {
                return 1;
            }
            return 0;
        }

        return dp[step][current + 2000] = ((recur(s, e, step + 1, current + 1, k) % MOD) + (recur(s, e, step + 1, current - 1, k) % MOD)) % MOD; 
    }

    int numberOfWays(int startPos, int endPos, int k) {
        dp.assign(5000, vector<long long>(5000, -1e9));
        return recur(startPos, endPos, 0, startPos, k) % MOD;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 112. Find The Longest Substring Containing Vowels In Even Counts

<details>
<summary> Approach </summary>

At the first glance it's like a sliding window problem. For a find maximum sliding window problem, the initial state should be valid, then keep extending the 2nd pointer until the state becomes invalid (now the maximum is found), then move the first pointer to get back the valid state again.

In this problem, the initial state is valid. When extending the 2nd pointer, the state might jump back and forth between invalid and valid before reaching the longest valid end position. So we shouldn't use sliding window to solve this problem.

Try to get the intuition by simplying the problem -- what if we only consider `a` as vowel?

```
    4    9   13  17
    v    v   v   v
xxxxaxxxxaxxxaxxxaxxx
    ~
         -1
             4
                 -1        
```


Consider the above input.

For `i = 0 ~ 3`, `0` `a` has been visited, substring `s[0..i]` is valid.

For `i = 4 ~ 8`, `1` `a` has been visited, substring `s[5..i]` is valid.

For `i = 9 ~ 12`, `2` `a`s have been visited, substring `s[0..i]` is valid.

For `i = 13 ~ 16`, `3` `a`s have been visited, substring `s[5..i]` is valid.

For `i = 17 ~ (N - 1)`, `4` `a`s have been visited, substring `s[0..i]` is valid.

So we can see there can be a greedy solution:

* If we've visited **even** number of `a`, substring `s[0..i]` is valid which has length `i + 1`.
* If we've visited **odd** number of `a`, substring `s[(k+1)..i]` is valid where `k` is the first index of the first occurrence of `a`. The length is `i - k`.

We can regard **even** and **odd** are two different states, then the above two cases can be unified into one:

* If we are in state `x` at index `i`, find the index of the first occurrence of the same state `x`, say `k`, then `i - k` is the length of the longest valid string ending at `i`.

Note that we need to regard `-1` as the index of the first occurrence of **even** state.

Now we consider the 5 vowels. Each vowel has two different states, **even** and **odd**. So in total there are `2^5` different states. We can use bitmask to encode the state.

For example, if the state of `aeiou` are even, even, odd, odd, even respectively, we can encode the state as `00110`.

Let `index` be a map from state `x` to the index of the first occurrence of state `x`.

For each index `i`, we get the corresponding state `mask` of `s[i]` first, then:
* If we've seen this state, then try to update the answer using `i - index[mask]`.
* Otherwise, `index[mask] = i`.

</details>


<details>
<summary> Solution - Prefix State Map </summary>

```cpp
int findTheLongestSubstring(string s) {
        int h = 0, ans = 0;
        unordered_map<int, int> m{{'a',0},{'e',1},{'i',2},{'o',3},{'u',4}}, index{{0,-1}};
        for (int i = 0; i < s.size(); ++i) {
            if (m.count(s[i])) h ^= 1 << m[s[i]];
            if (index.count(h)) ans = max(ans, i - index[h]);
            else index[h] = i;
        }
        return ans;
    }
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 113. Maximum Earnings From Taxi 

<details>
<summary> Solution </summary>

```cpp
long long maxTaxiEarnings(int n, vector<vector<int>>& A) {
    sort(A.begin(), A.end(), [](auto &a, auto &b) { return a[0] > b[0]; });
    
    map<int, long long> dp;
    dp[INT_MAX] = 0;
    
    long long ans = 0;
    
    for(auto &r : A) {
        int s = r[0], e = r[1], p = r[2];
        dp[s] = max(ans, e - s + p + dp.lower_bound(e)->second);
        ans = max(ans, dp[s]);
    }
    
    return ans;
}
```
</details>

<br>[⬆ Back to top](#table-of-contents)

## 114. Vertical Order Traversal Of A Binary Tree 

<details>
<summary> Solution </summary>

```cpp
class Solution {
public:
    vector<vector<int>> answer;
    map<int, map<int, multiset<int>>> m;
    
    void dfs(TreeNode* root, int x, int y) {
        if(!root) {
            return;
        }
        
        m[x][y].insert(root->val);
        
        dfs(root->left, x - 1, y + 1);
        dfs(root->right, x + 1, y + 1);
    }
    
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        dfs(root, 0, 0);
        
        for(auto &[mm, mm1]: m) {
            answer.emplace_back();
            for(auto &[mm2, vals] : mm1) {
                for(int n : vals) {
                    answer.back().push_back(n);
                }     
            }
        }
        
        return answer;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 115. Invert Binary Tree 

<details>
<summary> Solution </summary>

```cpp
TreeNode* invertTree(TreeNode* root) {
    if(!root) {
        return NULL;
    }
    
    swap(root->left, root->right);
    
    invertTree(root->left);
    invertTree(root->right);
    
    return root;
}
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 116. Count Primes 

<details>
<summary> Solution </summary>

```cpp
int countPrimes(int n) {
    vector<bool> primes(n + 1, true);
    int cntPrimes = 0;
    
    for(int i = 2; i < n; i++) {
        if(!primes[i]) {
            continue;
        }
        
        cntPrimes++;
        for(int j = i; j < n; j += i) {
            primes[j] = false;
        }
    }
    
    return cntPrimes;
}
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 117. Find The Shortest Superstring 

<details>
<summary> Solution </summary>

```cpp
class Solution {
public:
    string shortestSuperstring(vector<string>& A) {
        int n = A.size();
        
        vector<vector<int>> overlaps(n, vector<int>(n));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                int m = min(A[i].size(), A[j].size());
                for (int k = m; k >= 0; --k) {
                    if (A[i].substr(A[i].size() - k) == A[j].substr(0, k)) {
                        overlaps[i][j] = k;
                        break;
                    }
                }
            }
        }
  
        // dp[mask][i] = most overlap with mask, ending with ith element
        vector<vector<int>> dp(1<<n, vector<int>(n, 0));
        vector<vector<int>> parent(1<<n, vector<int>(n, -1));
        
        for (int mask = 0; mask < (1<<n); ++mask) {
            for (int bit = 0; bit < n; ++bit) {
                if (((mask>>bit)&1) > 0) {
                    int pmask = mask^(1<<bit);
                    if (pmask == 0) continue;
                    for (int i = 0; i < n; ++i) {
                        if (((pmask>>i)&1) > 0) {
                            int val = dp[pmask][i] + overlaps[i][bit];
                            if (val > dp[mask][bit]) {
                                dp[mask][bit] = val;
                                parent[mask][bit] = i;
                            }
                        }
                    }
                }
            }
        }
        
        vector<int> perm;
        vector<bool> seen(n);
        int mask = (1<<n) - 1;
        
        int p = 0;
        for (int i = 0; i < n; ++i) {
            if (dp[(1<<n) - 1][i] > dp[(1<<n) - 1][p]) {
                p = i;
            }
        }
        
        while (p != -1) {
            perm.push_back(p);
            seen[p] = true;
            int p2 = parent[mask][p];
            mask ^= (1<<p);
            p = p2;
        }
        
        reverse(perm.begin(), perm.end());
        
        for (int i = 0; i < n; ++i) {
            if (!seen[i]) {
                perm.push_back(i);
            }
        }
        
        string ans = A[perm[0]];
        for (int i = 1; i < n; ++i) {
            int overlap = overlaps[perm[i - 1]][perm[i]];
            ans += A[perm[i]].substr(overlap);
        }
        
        return ans;
        
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 118. Sum Root To Leaf Nodes 

<details>
<summary> Solution </summary>

```cpp
class Solution {
public:
    int ans = 0;
    
    void dfs(TreeNode* root, int sum) {
        if(!root) return;
        sum = sum * 10 + (root->val);
        
        if(!root->left && !root->right) ans += sum;
        
        dfs(root->left, sum);
        dfs(root->right, sum);
    }
    
    int sumNumbers(TreeNode* root) {
        dfs(root, 0);
        return ans;
    }
};
```

</details>

<br>[⬆ Back to top](#table-of-contents)


## 119. Longest Common Subsequence

<details>
<summary> Solution </summary>

```cpp
int longestCommonSubsequence(string s, string t) {
    int M = s.size(), N = t.size();
    vector<vector<int>> dp(M + 1, vector<int>(N + 1, 0));
    
    for(int i = 1; i <= M; i++) {
        for(int j = 1; j <= N; j++) {
            if (s[i - 1] == t[j - 1]) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[M][N];
}
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 120. Count Number of Maximum Bitwise Or Subsets

<details>
<summary> Solution </summary>

```cpp
int countMaxOrSubsets(vector<int>& nums) {    
    int N = nums.size(), maxOr = 0;
    for(auto a : nums) maxOr |= a;
    
    int subsetCnt = 0;
    
    for(int mask = 0; mask < (1 << N); mask++) {
        int subsetOr = 0;
        for(int i = 0; i < N; i++) {
            if(mask >> i & 1) {
                subsetOr |= (nums[i]);
            }
        }
        
        if(subsetOr == maxOr) subsetCnt++;
    }
    
    return subsetCnt++;
}
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 121. Jump Game III

<details>
<summary> Solution - DP </summary>

```cpp
bool canReach(vector<int>& A, int start) {
    if(start < 0 || start >= A.size() || A[start] < 0) return false;
    
    if(A[start] == 0) return true; 
    A[start] *= -1;
    
    return canReach(A, start + A[start]) || canReach(A, start - A[start]);
}
```

</details>

<br>[⬆ Back to top](#table-of-contents)

## 122. Operations on Tree 

<details>
<summary> Solution </summary>

```cpp
```

</details>

<br>[⬆ Back to top](#table-of-contents)


## 123. Minimum Operations To Convert Number

<details>
<summary> Solution </summary>

```cpp
```

</details>

<br>[⬆ Back to top](#table-of-contents)


## 124. Egg Drop With 2 Eggs and N Floors

<details>
<summary> Solution </summary>

```cpp
```

</details>

<br>[⬆ Back to top](#table-of-contents)


## 125. Problem Name 

<details>
<summary> Solution </summary>

```cpp
```

</details>

<br>[⬆ Back to top](#table-of-contents)
